---
owner: Ben Jendyk
id: 2de92f5d-2e55-47b4-9bf9-a005ee042ef0
created: 2025-06-15T23:42:24+0200
modified: 2025-07-08T06:07:48+0200
tags: [access/public, language/en, pr/25/116, tf/quarter]
key-words: []
---

Certainly. Here's the **step-by-step setup** presented as a linear, clearly structured procedure--without tables, optimized for readability and direct execution.
* * *

## STEP-BY-STEP SETUP -- MINIMAL SPINE FROM ZERO
* * *

### 1. **Secure Root Identity**

- Register a domain for your company (e.g. `corpname.com`).
- Set up Google Workspace (Business Starter or Standard).
- Buy and configure two FIDO2 hardware keys (e.g. YubiKey).
- In Google Admin Console:  
→ Enable 2FA using security key for all founders.  
→ Enforce domain-wide admin login only via SSO.

✅ _You now have a secure, standards-based identity provider (OIDC)._

* * *

### 2. **Create GitHub Organization**

- Go to GitHub → create a new organization (name: `corpname`).
- Choose "Team" plan (cheapest with required features).
- Go to GitHub Org Settings → "Security" → enable SAML SSO via your Google Workspace domain.

✅ _Your Git ledger is now gated by corporate identity._

* * *

### 3. **Bootstrap Your Repositories**

- Initialize three Git repos:

    - `doctrine` -- for operating doctrine and templates.

    - `projects` -- all Projects live here as folders.

    - `shared-library` -- reusable assets (tokens, components).

You can create these via the GitHub UI or use the CLI:
    
    
    gh repo create doctrine --private
    gh repo create projects --private
    gh repo create shared-library --private
    

✅ _Your basic repository structure is live._

* * *

### 4. **Provision Object Storage (S3-Compatible)**

- Sign up for **Cloudflare R2** (or use AWS S3).
- Create three buckets:

    - `assets` -- for design files, PDFs, exports.

    - `git-lfs` -- for Git LFS file pointers.

    - `backups` -- for Postgres snapshots, logs.
- Create a scoped API token (e.g., `ci-runner`) with write access.

✅ _You now have an industrial-grade object vault._

* * *

### 5. **Configure Git LFS**

Install Git LFS and configure it:
    
    
    brew install git-lfs
    git lfs install
    git config --global lfs.url https://<your-R2-endpoint>/git-lfs
    

✅ _Git is now ready to push large binary files to R2._

* * *

### 6. **Provision a Structured SQL Core**

- Sign up at [neon.tech](https://neon.tech/) (serverless Postgres).
- Create your first project and database.
- Define schemas and tables:
    
    
    CREATE SCHEMA metrics;
    CREATE TABLE metrics.kpi (
      id SERIAL PRIMARY KEY,
      name TEXT,
      target NUMERIC,
      actual NUMERIC
    );
    
    CREATE SCHEMA risks;
    CREATE TABLE risks.register (
      id SERIAL PRIMARY KEY,
      description TEXT,
      likelihood INT,
      impact INT,
      owner TEXT
    );
    

✅ _You now have a structured, cloud-native, versioned SQL store._

* * *

### 7. **Install Terraform and Lock Infra State**

- Install Terraform CLI:
    
    
    brew install terraform
    

- Configure S3-backed state:
    
    
    terraform {
      backend "s3" {
        bucket = "tfstate"
        key    = "state/global.tfstate"
        region = "auto"
      }
    }
    

- Initialize and apply:
    
    
    terraform init
    terraform apply
    

✅ _Your infra state is version-controlled and remote._

* * *

### 8. **Install a GitHub Actions Runner**

Set up your own CI runner:
    
    
    mkdir /srv/runner && cd /srv/runner
    curl -o actions.tar.gz https://github.com/actions/runner/releases/latest/download/actions-runner-linux-x64.tar.gz
    tar xzf actions.tar.gz
    ./config.sh --url https://github.com/<org> --token <repo-token>
    sudo ./svc.sh install
    sudo ./svc.sh start
    

✅ _You now have automation capacity for pipelines and checks._

* * *

### 9. **Write Your First CI Workflow**

Inside any repo, create `.github/workflows/lint.yml`:
    
    
    name: Spine Lint
    
    on: [push]
    
    jobs:
      lint:
        runs-on: self-hosted
        steps:
          - uses: actions/checkout@v4
          - name: Lint YAML
            run: yamllint .
          - name: Push Git LFS
            run: git lfs push --all origin
    

✅ _Every push now runs governance automation._

* * *

### 10. **Deploy Retool (Web Interface Layer)**

- Sign up for [Retool Cloud](https://retool.com/).
- Connect:

    - Your Neon Postgres instance.

    - Your S3-compatible storage (via API keys).
- Build:

    - "Mission Console" → show Missions, allow uploads, show metrics.

    - Upload widget that writes to `assets/`.

✅ _You now have a working UX for non-technical users._

* * *

### 11. **Connect Slack for Operational Chat**

- Create a Slack workspace.
- Install the Retool + Slack integration.
- Define custom slash commands (e.g. `/upload`, `/decision`, `/status`) that:

    - Trigger Retool workflows via API.

    - Post confirmation or data back into Slack.

✅ _Mission-related workflows now operate inside chat._

* * *

### 12. **Run First Operational Flow**

- In Retool:

    - Create first Project folder in `projects/25-P001`.

    - Create first Mission → auto-creates Git branch `mission/M01`.
- Upload a PDF or image → lands in R2 via Retool.
- FO commits `MasterContent.md` update in GitHub.
- GitHub Action tags it; audit log written to Postgres.

✅ _You now have a functioning company backbone, executing in versioned, auditable steps._

* * *

This spine will **scale with you**--without rework, technical debt, or losing strategic integrity. Every layer is protocol-based, vendor-swappable, and ready for structured growth.