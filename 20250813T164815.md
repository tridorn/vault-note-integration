---
owner: Ben Jendyk
id: 3bd115f7-6244-4286-b465-da6cb6719abc
created: 2025-08-13T16:48:15+0200
modified: 2025-08-13T16:48:18+0200
tags: [access/public, language/en]
key-words: []
aliases: [Objectives]
title: Objectives
---

You should have asked: "Design a practical taxonomy and repository strategy for all my code artifacts (scripts, libraries, services, infra, experiments) so they're easy to find, govern, and evolve."

  

# Objectives

  

Reduce entropy, speed onboarding, enforce quality. The structure below scales from a solo setup to a small team without ceremony.

  

# Asset categories and how to host them

  

Treat each category as a distinct "product" with its own repo archetype, release model, and tests.

1. Operational scripts (one-off or cronable)

  

- Purpose: glue tasks, maintenance, migrations.
- Repo archetype: ops-<domain>-scripts
- Structure:
    
    
    /scripts/<topic>/<name>.(sh|py|ps1)
    /scripts/lib/            # shared helpers
    /tests/                  # smoke tests for critical scripts
    /docker/                 # runtime image if needed
    /taskfiles/Makefile|justfile|Taskfile.yml

-   
- Release model: tag by date and intent, e.g. 2025.08-maintenance, not SemVer.
- Quality: shellcheck/ruff/black; dry-run flags required; idempotency where feasible.

  

2. Reusable libraries (language packages)

  

- Purpose: code reused across projects.
- Repo archetype: lib-<lang>-<domain>
- Structure:
    
    
    /src/<pkg>/
    /tests/
    /examples/

-   
- Release model: SemVer with changelog; publish to package registry.
- Quality: full unit tests, API docs, deprecation policy.

  

3. Long-running services (APIs, daemons, CLIs that act like products)

  

- Purpose: user- or system-facing binaries/services.
- Repo archetype: svc-<name>
- Structure:
    
    
    /cmd/<binary>/
    /internal/ or /src/
    /deploy/helm|terraform
    /infra/ (if tightly coupled)
    /configs/
    /tests/ (unit + contract)
-   
- Release model: SemVer; container images tagged vX.Y.Z and main-SHORTSHA.
- Quality: unit + integration + healthcheck; runbooks in /docs/runbook.md.

  

4. Infrastructure-as-Code

  

- Purpose: environments, networks, policies.
- Repo archetype: infra-<scope>
- Structure:
    
    
    /envs/dev|staging|prod/
    /modules/
    /policies/ (OPA, Sentinel)

-   
- Release model: environment-locked; PRs gated by plan diffs; no drift.
- Quality: policy-as-code tests; static analyzers (tflint, checkov).

  

5. Automation pipelines and workflows

  

- Purpose: ETL jobs, schedulers, CI logic reused across repos.
- Repo archetype: automation-<platform> (e.g. automation-github, automation-airflow)
- Structure:
    
    
    /workflows/ or /dags/
    /lib/
    /tests/

-   
- Release model: versioned bundles; referenced as reusable workflows/submodules.

  

6. Data science and analysis

  

- Purpose: notebooks, experiments, reports.
- Repo archetype: lab-<topic> for experiments, report-<topic> for published analyses.
- Structure:
    
    
    /notebooks/
    /src/
    /data/ (gitignored; use DVC or pointers)
    /models/ (tracked via MLflow/DVC)

-   
- Release model: stamped reports; experiments are disposable.
- Quality: pin environments; deterministic seeds; capture provenance.

  

7. Templates and scaffolds

  

- Purpose: opinionated starting points.
- Repo archetype: template-<stack> (e.g. template-fastapi-svc)
- Structure: minimal working example + bootstrap.sh or copier/cookiecutter config.
- Release model: tagged templates; changelog documents breaking template changes.

  

8. Dotfiles and developer tooling

  

- Purpose: reproducible dev environment.
- Repo archetype: dotfiles and devcontainer-<lang>
- Structure: modular; per-OS overlays.
- Release model: date-based tags; keep README with install steps.

  

9. Org-wide policy and knowledge

  

- Purpose: single source of truth for rules and standards.
- Repo archetype: handbook and standards
- Structure:
    
    
    /coding/
    /security/
    /ci/
    /review/

-   
- Release model: version documents; PRs required for any policy change.

  

# Monorepo vs polyrepo

- Choose monorepo if you need atomic, cross-service changes and shared versioning; enforce clear boundaries with tooling and owners.
- Prefer polyrepo for clean ownership, independent lifecycles, simpler access control. For a small org, polyrepo per category above is usually lower-friction.

  

# Naming, discoverability, ownership

- Prefix by type: ops-, lib-, svc-, infra-, automation-, lab-, template-.
- Suffix with domain: -audio, -billing, -auth.
- Each repo must have:

    - README.md: purpose, quickstart, support status.

    - LICENSE

    - CODEOWNERS: one accountable owner; backups listed.

    - SECURITY.md: how to report issues.

    - CONTRIBUTING.md: branch, test, release rules.

  

# Branching, releases, environments

- Branching: trunk-based with short-lived feature branches; protect main.
- Releases: libraries and services use SemVer; scripts and notebooks use date tags.
- Changelogs: keep human-written CHANGELOG.md.
- Environments: dev, staging, prod mirrored in config, not in code forks.

  

# CI/CD baselines (apply org-wide)

- Reusable GH Actions in automation-github referenced by all repos.
- Mandatory checks:

    - Lint + format

    - Unit tests with coverage threshold

    - SCA and secret scanning

    - Container scan for services

    - IaC plan + policy checks for infra
- Release job creates tags, artifacts, and publishes packages/images.
- Provenance: supply-chain metadata (SBOM, attestations) emitted on release.

  

# Security and secrets

- No secrets in code. Use a secrets manager; CI pulls ephemeral credentials.
- Mandatory pre-commit hooks for secret detection.
- Least-privilege tokens per repo, not org-wide tokens.

  

# Data and artifacts

- Large files via Git LFS or DVC; enforce size limits in server-side hooks.
- Artifacts stored in registries or object storage; never in repo history.

  

# Documentation rules

- Each repo: concise README with tasks table, runbook for services, maintenance windows for ops repos.
- Central "handbook" links to every repo; auto-generate an index from org API nightly.

  

# Lifecycle states and deprecation

- Labels: incubating, active, maintenance, deprecated, archived.
- Archive criteria: 90 days inactivity, no owner, or superseded. Add a tombstone README that points to the successor.

  

# Minimal directory archetypes

  

Library:
    
    
    /src/<pkg>/
    /tests/
    /docs/
    /.gh/workflows/reuse.yml
    /.tool-versions or /requirements.txt
    /pyproject.toml or equivalent

Service:
    
    
    /cmd/<binary>/
    /internal/ or /src/
    /configs/
    /deploy/
    /tests/unit
    /tests/integration
    /docs/runbook.md

Ops scripts:
    
    
    /scripts/<topic>/
    /scripts/lib/
    /tests/
    /Makefile or justfile

Infra:
    
    
    /envs/dev|staging|prod/
    /modules/
    /policies/
    /pipelines/

# Population strategy (practical steps)

1. Inventory existing code. Tag each repo with one of the categories. Rename to follow prefixes.

2. Split mixed-purpose repos. Extract scripts from app repos into ops-….

3. Create templates for each archetype. Enforce via new-repo checklist and scaffold tool.

4. Centralize CI as reusable workflows; delete bespoke pipelines.

5. Add CODEOWNERS and lifecycle labels to every repo. No orphaned code.

6. Migrate secrets out; add scanners and size limits.

7. Standardize release models per category; backfill tags for current state.

  

# Quick decision matrix

- Short-lived glue with low reuse → ops-<domain>-scripts
- Reusable logic used by 2+ projects → lib-<lang>-<domain>
- Always-on, exposed functionality → svc-<name>
- Environments, networks, clusters → infra-<scope>
- Shared pipelines/workflows → automation-<platform>
- Research, trials, notebooks → lab-<topic>
- Starting points → template-<stack>
- Developer environment → dotfiles, devcontainer-<lang>
- Policies and knowledge → handbook, standards

  

Adopt this verbatim, then iterate by exception.