---
owner: Ben Jendyk
id: a784b64c-e613-4337-890e-aec69b9fa90c
created: 2025-08-12T00:29:26+0200
modified: 2025-08-12T00:29:26+0200
tags: [access/public, language/en]
key-words: []
---

Correction: You should have asked: “Assuming the end-state is a deterministic, system-defined organisation as described above, how does a single individual begin laying that foundation from zero—what’s the minimal viable structure for a 1-person company with that ambition?”

⸻

I. Principle

You are not writing code to build a company. You are writing the company as code.

This reframes the goal. You’re not “bootstrapping a product”—you’re bootstrapping an institutional system with no manual components. Every input, action, and output is part of a defined operational structure, version-controlled and reproducible.

The outcome is not just software. The outcome is a codified organisation.

⸻

II. Foundational Directives (Single-Person Phase)

Category	Rule
All state in Git	No secrets in memory, no config on disk, no random tools
Rebuildable system	Dev env, infra, laptop, docs must be regenerable from code
Uniform interfaces	You operate via pull requests—even if you’re the only one
No mutability drift	Never manually change prod, systems, or workstation state
Workflows are productised	You version your processes the way you version APIs


⸻

III. Directory Layout (First Repo)

You start with a single infra or ops repo that becomes your canonical org source:

infra/
├── flake.nix                     # Root flake for everything
├── hosts/
│   ├── laptop.nix                # Declarative workstation
│   └── servers.nix               # Your server(s)
├── services/
│   ├── api.nix                   # Your product’s infra
│   └── observability.nix         # Prometheus, Grafana, etc
├── people/
│   └── you.nix                   # Your identity, access, roles
├── secrets/
│   └── agenix/                   # Encrypted secrets
├── ci/
│   └── pipelines.nix             # Buildkite or GitHub Actions
├── docs/
│   └── handbook.md               # Org process as README
└── pkgs/
    └── default.nix               # Overlays or custom packages

This becomes the substrate for everything else. New hires, new machines, new services—all flow from here.

⸻

IV. Core Stack Choices (Single-Operator, Deterministic)

Domain	Tool	Reason
Base OS	NixOS	Immutable, reproducible, modular
Dev Shells	devShells in flake.nix	Language-agnostic, reproducible environments
Secrets Mgmt	agenix (with GPG or age keys)	Git-based secrets encryption
Cloud Infra	Terraform (or Pulumi if needed)	Infra-as-code for provisioning cloud
CI/CD	GitHub Actions (Nix-based runners)	Hooks into flake builds, image builds
Artifact Store	S3 or MinIO	Store builds, state, and logs
ChatOps (Future)	Slack or Matrix bot	Trigger infra, notify builds
Documentation	Markdown in Git + static-site builder	Handbook, SOPs, architecture refs
Monitoring	Prometheus + Grafana, deployed via Nix	Full reproducibility of telemetry stack


⸻

V. Initial Setup Actions (0 to Viable)
	1.	Install NixOS on laptop
	•	Define your own flake: hosts/laptop.nix
	•	Include home-manager module for dotfiles, CLI tools, UI
	2.	Create initial flake.nix
	•	Inputs: nixpkgs, home-manager, agenix, any overlays
	•	Outputs: host configs, devShells, server config
	3.	Set up GitOps repo
	•	Your infra repo is bootstrapped from this flake
	•	Push to GitHub, create private CI (self-hosted or GH Actions)
	4.	Build and push binary cache
	•	Optional now, essential later
	•	Use Cachix or self-hosted S3 + nix-serve
	5.	Provision server (optional)
	•	Use nixos-anywhere or deploy-rs
	•	First target: staging API, observability, or test project
	6.	Codify workflows
	•	Write a markdown doc for each critical process:
	•	Deploying
	•	Building images
	•	Granting access
	•	Publishing docs
	•	Setting up a dev env

Each workflow should be executable and rebuildable, not a checklist.

⸻

VI. First Real System Loop
	1.	Create an MVP service (e.g., an API)
	2.	Declare it in services/api.nix — ports, reverse proxy, DB, etc.
	3.	Build it via nix build .#apiImage
	4.	Push to registry via CI pipeline
	5.	Deploy by merging an overlay into hosts/servers.nix
	6.	Verify via Prometheus probe

From here, repeat. Every new service, tool, or employee is an extension of the system.

⸻

VII. What You Avoid
	•	Onboarding documents
	•	Undocumented scripts
	•	Drifted machines
	•	Devs manually patching prod
	•	“How did we do this last time?”
	•	Random dependencies
	•	Unverified deploys
	•	Configuration entropy

⸻

VIII. Mental Model

You’re not a startup founder.
You’re the first compiler engineer for a sovereign system.
The initial flake is your kernel.
The first CI job is your scheduler.
The first markdown doc is your userland.
Every commit is a state transition.
Every PR is a governance proposal.

⸻

IX. Reality Check: This is Slower at First

Traditional solo founder	You, infrastructure-native
Installs Arch, starts coding	Flashes NixOS, writes flake.nix
Pushes to GitHub manually	Defines CI pipelines and artifact storage
Deploys via shell scripts	Deploys via Git merge and GitHub Actions
Onboards with Google Docs	Onboards with a reproducible ISO + SOP repo

The time cost is real.
But so is the compound gain:
You scale to 10, 100, 1000 systems with zero added entropy.

⸻

X. Bottom Line

The single-person company that thinks in systems must build system-first.
Start with a Git repo, a Nix flake, and the discipline to never escape into “just this once” workflows.

You’re not building a company on infrastructure.
You’re building the company as infrastructure.