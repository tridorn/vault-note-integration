# Dually-Mirrored Obsidian Note System (Condensed)

## Toolchain

* **Templater**: JS logic, YAML edit, body insert.
* **Dataview**: Render YAML in body.
* **MetaEdit**: Optional YAML tweaks.
* **QuickAdd**: Optional macros.
* **Linter**: Auto timestamps, rev count, word count.

## Structure

```
00_System/
 ├─ Templates/
 │   ├─ _core.md
 │   ├─ blocks/ (flow, taxonomy, links, content…)
 │   └─ scripts/block-helper.js
 └─ Guides/
```

Templater set to these folders.

## Block Helper (`block-helper.js`)

* **Merge YAML**: updates block with defaults.
* **Insert section**: adds numbered `## N Heading` if missing; leaves prose untouched.
* **Extensible**: same helper works for all blocks.

## Example Block Template (`flow.md`)

* Ensures `flow` exists with defaults.
* Inserts `## Flow` section with Dataview table.
* Re-running updates YAML, table auto-reflects.

## Core Template (`_core.md`)

* Initializes `core` metadata (uid, timestamps, rev).
* Inserts `## Core` with Dataview table.

## Usage

* Hotkeys mapped to block templates.
* QuickAdd macro can chain (flow → taxonomy → links → content).

## Sync & Validation

* **Linter**: updates `core.updated`, increments `rev`, writes word count.
* **Folder hooks**: moving a file triggers flow block update (`flow.stage`).
* **Optional nightly script**: write backlink count to `metrics`.

## Editing Rules

* Change data = YAML edit or block template.
* Narrative = write below Dataview snippet.
* H1 title = Linter syncs to YAML.
* New blocks = add template, call helper.

## Lifecycle

1. New note → Core scaffold (flow: capture).
2. Update stage/status via flow block.
3. Add taxonomy, links, content via shortcuts.
4. QuickAdd macro promotes to library.

## Why it works

* One JS helper centralizes logic.
* Dataview = single source of truth (YAML).
* Safe to re-run templates (idempotent).
* Numbering automatic, append-only.
* Extensible with minimal friction.

