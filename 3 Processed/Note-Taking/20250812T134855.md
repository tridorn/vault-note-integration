# Unified, Dual-Purpose System for Notes

### 1. Why unify

Different templates fragment a knowledge base, making queries and automation brittle. A unified schema keeps every note compatible:

* Same set of blocks across all types.
* Works equally for static notes (books, papers) and dynamic ones (projects).
* Eliminates the need for “bridging” scripts.

### 2. Dual-purpose blocks

Each block has two faces:

* **Meta (YAML):** machine-readable, factual source of truth.
* **Body (H2 section):** human-readable interpretation or narrative.
  Linked by name to avoid “orphan” data.

### 3. The twelve primitives

Minimal universal set of functions any note may need:

* **identity:** unique ID and type.
* **intent:** why the note exists.
* **sources:** bibliographic references.
* **inputs:** raw materials (datasets, files).
* **method:** approach or workflow.
* **content:** main prose or draft.
* **findings:** raw outputs, observations, results.
* **conclusions:** interpretations or decisions.
* **next:** open actions or questions.
* **state:** lifecycle and classification.
* **ledger:** history of changes.
* **links:** graph connections.

### 4. Static vs. dynamic notes

Static notes leave many fields minimal or empty; dynamic ones actively use method, next, ledger, and evolving state. Structure remains identical, so queries cut across both.

### 5. Why split sources and inputs

* **sources =** citable references (books, articles, DOIs).
* **inputs =** uncitable materials (datasets, transcripts, assets).
  This separation enables clean bibliographic queries without noise.

### 6. Querying advantages

Uniform primitives allow:

* Listing all notes with open actions.
* Filtering by citation (e.g. DOI, ISBN).
* Generating reading queues (type=book, state=open).

### 7. Adaptability and resilience

* Composable: new blocks can be added without breaking the base.
* Scalable: works for a handful or thousands of notes.
* Human-resilient: even without Dataview, mirrored fields keep the note intelligible.
