# Unified, Dual-Purpose Note System (Core)

### 1. Why unified

Different templates fragment a knowledge base. A single grammar ensures:

* Same blocks across all notes.
* Querying works universally (stage, sources, conclusions).
* No bridging scripts between note types.

### 2. Why dual-purpose

Each block has two faces:

* **Meta (YAML)**: machine-readable, source of truth.
* **Body (H2)**: human-readable, interpretation.
  Linked by name, preventing orphaned data.

### 3. The 12 primitives

Minimal, universal “jobs” of a note:

* **identity** – type, unique ID.
* **intent** – why the note exists.
* **sources** – bibliographic references.
* **inputs** – non-bibliographic material (datasets, files).
* **method** – approach or process.
* **content** – main prose or draft.
* **findings** – raw outputs (quotes, results).
* **conclusions** – interpretation or decisions.
* **next** – follow-up action or open question.
* **state** – lifecycle stage, status.
* **ledger** – timeline of changes.
* **links** – graph connections (parents, dependencies).

### 4. Static vs action notes

Static notes: minimal next, single state=done, no ledger.
Action notes: active use of method, next, ledger, evolving state.
Both remain structurally identical, enabling shared queries.

### 5. Why split sources and inputs

* **sources** = citable works (books, papers).
* **inputs** = working materials (datasets, assets).
  Prevents mixing references with raw material; enables clean bibliographic queries.

### 6. Machine-querying advantage

Consistent fields allow:

* Table of open questions (`next.action` where state != done).
* Filter notes by DOI/ISBN.
* Generate reading queues (type=book, state=open).

### 7. Adaptability and scalability

* Composable: add optional blocks (risks, terms).
* Scalable from 10 to 10,000 notes.
* Resilient: notes remain human-meaningful without queries.

