
# why enums? a rational take

**Goal**: one schema that covers every note type without proliferating keys.
**Strategy**: keep a stable shape, specialize with enums for constrained variation.

**Benefits**

* Queryable: simple dashboards (`WHERE state.stage="review"`).
* Interoperable: same keys across domains.
* Evolvable: add values without breaking.
* Consistent: avoids synonyms.

**Trade-offs**

* Coarse: enums lack nuance vs. structured fields.
* Migration: changing vocab requires pass.
* Discoverability: solve with reference vocab block.

**Rule of thumb**

* Categorical variation: enum.
* Structured/nested variation: new object key.
* Free text/explanation: body.

---

## universal schema (meta, trimmed)

```yaml
identity:
  id: ...
  title: ""
  type: note        # enum: note|book|paper|project|concept|meeting|experiment
  authors: []
  created: ...
  updated: ...

purpose: {question: "", outcome: ""}

bounds: {criteria: [], assumptions: [], constraints: []}

materials:
  items: []         # [{id, kind, title, ref, meta}]
  # kind (enum): source|data|prompt|requirement|note
  key_source: ""

content: {mode: summary, template: ""}  # enum: summary|analysis|draft|build|notes

claims:
  items: []         # [{id, kind, statement, supports:[id], confidence:0-1}]
  # kind: finding|insight|decision|hypothesis|quote_thesis

artifacts:
  items: []         # [{id, kind, name, path|url, derived_from:[id]}]
  # kind: file|figure|table|deliverable|highlight

actions: {next: {action:"", owner:"", due:""}, backlog: []}

state:
  stage: capture    # capture|clarify|compose|review|publish|archive
  status: open      # open|blocked|waiting|done|n/a
  project: ""
  priority: normal  # low|normal|high|urgent
  started: ""
  finished: ""
  rating: null

links: {parent:"", children:[], depends_on:[], related:[], topics:[]}
ledger: {entries: []}
```

How enums reduce keys: encode role and lifecycle directly (`type`, `content.mode`, `claims.kind`, `artifacts.kind`, `state.stage`, `state.status`, `state.priority`).

---

## when not to use enums

For type-specific metadata (e.g. paper: journal, volume, pages): add a structured object, not new schema shape.

```yaml
identity: {type: paper}
bibliography: {journal:"", year:0, volume:"", issue:"", pages:"", doi:""}
```

---

## vocab reference (pin separately)

```yaml
type: [note, book, paper, project, concept, meeting, experiment]
content_mode: [summary, analysis, draft, build, notes]
claim_kind: [finding, insight, decision, hypothesis, quote_thesis]
artifact_kind: [file, figure, table, deliverable, highlight]
stage: [capture, clarify, compose, review, publish, archive]
status: [open, blocked, waiting, done, n/a]
priority: [low, normal, high, urgent]
```

Version the vocab to manage migrations.

---

## obsidian dataview snippets (core only)

**materials table**

```dataview
TABLE kind, title, ref
FROM this
FLATTEN materials.items as m
WHERE m.kind AND m.title
```

**claims list**

```dataview
LIST ("**" + c.kind + "**: " + c.statement +
     (length(c.supports) > 0 ? " ↳ supports: " + c.supports : ""))
FROM this
FLATTEN claims.items as c
```

**state chips**

```js
const s = dv.current().state;
dv.paragraph(`Stage: ${s.stage} • Status: ${s.status} • Priority: ${s.priority}`);
```

**next action banner**

```js
const n = dv.current().actions?.next;
if (n && (n.action || n.due)) {
  dv.paragraph(`➡️ **Next:** ${n.action||""} ${n.owner? "• @"+n.owner:""} ${n.due?"• due "+n.due:""}`);
}
```

---

## governance & evolution

* **Version schema** (bump when enums or blocks change).
* **Soft-validation**: dataview checks for invalid enums.
* **Migrations**: keep search/replace steps in a log.
* **Defaults**: keep blocks present (avoid missing-field queries).

---

## decision matrix (condensed)

| Need                     | Enum | New key | Body |
| ------------------------ | ---- | ------- | ---- |
| known categories         | ✅    |         |      |
| lifecycle state/priority | ✅    |         |      |
| bibliographic fields     |      | ✅       |      |
| ethics/legal             |      | ✅       |      |
| rationale/explanation    |      |         | ✅    |
| ad-hoc tags              |      |         | ✅    |

---

## bottom line

Enums keep schema universal, cut key sprawl, and support querying.
Add structured sub-objects when domain demands it.
Keep prose nuance in body, facts in meta, and mirror only what aids reading.

