---
owner: Ben Jendyk
id: 9cbc2706-3603-4920-9e65-b1c6f9c75428
created: 2025-08-12T00:29:59+0200
modified: 2025-08-12T00:29:59+0200
tags: [access/public, language/en]
key-words: []
aliases: [tasks/2024-001.yaml]
title: tasks/2024-001.yaml
---

Correction: You should have asked: “Expand on the list of primitives—how should each be implemented, structured, and connected to form a coherent, deterministic operational system starting from a one-person infrastructure-native company?”

⸻

I. Purpose of Primitive Modelling

These primitives form the entire operational graph of the organisation. Nothing exists outside this model—no floating tasks, no unversioned state, no untracked access.

Each primitive represents one domain object, designed to:
	•	Be fully declarative
	•	Live in Git
	•	Be hashable and diffable
	•	Interact via explicit references

They are not abstractions. They are concrete, composable artefacts used daily.
Your role is not to manage people or tasks, but to maintain the integrity of this graph.

⸻

II. Minimum Viable Implementations

Below is a structured, implementable view of each primitive class, their storage layout, and integration.

1. Repositories
	•	Structure: One mono-repo (initially) with clear module boundaries: /infra, /services, /apps, /people, /data
	•	Management: GitHub or self-hosted Gitea with PR enforcement
	•	Interface: All change flows via git push → PR → review → merge → CI → deploy

infra/
  flake.nix
  hosts/
  services/
  ci/


⸻

2. Tasks & Epics
	•	Structure: Git-tracked markdown in /tasks/ and /epics/
	•	Schema:

# tasks/2024-001.yaml
id: 2024-001
title: "Set up CI cache"
status: in-progress
assignee: you
epic: epic-001
depends_on: []

	•	Interface: Tasks are referenced in commits, branch names, PRs. Closed by merging. Fully local.

⸻

3. CI Pipelines
	•	Tool: GitHub Actions, Buildkite, or Drone
	•	Defined in: /ci/pipelines.nix or .github/workflows/build.yml
	•	Inputs: Code, flake.nix, secrets
	•	Outputs: Artefacts, notifications, status

jobs:
  build:
    steps:
      - run: nix build .#service-api
      - run: ./ci/test.sh


⸻

4. Artefacts
	•	Format: OCI images, binaries, SBOMs, docs
	•	Storage: S3 bucket (artefacts/org-name/sha256/)
	•	Tracked via: CI pipeline outputs
	•	Accessed via: Commit hash + tag

⸻

5. System Roles / Hosts
	•	Format: Nix modules
	•	Defined in: /infra/hosts/laptop.nix, /infra/hosts/staging-server.nix
	•	Rebuilt via: nixos-rebuild switch --flake .#laptop

{
  networking.hostName = "laptop";
  services.sshd.enable = true;
  users.users.yourname = {
    isNormalUser = true;
    openssh.authorizedKeys.keys = [ "ssh-rsa ..." ];
  };
}


⸻

6. Secrets
	•	Tool: Agenix
	•	Encrypted with: age or GPG
	•	Defined in: /infra/secrets/production.age
	•	Decrypted at runtime by Nix modules only on matching hosts

⸻

7. Principals (Users)
	•	Format: /people/you.nix
	•	Attributes: SSH keys, roles, access scopes, email
	•	Propagated to: Host Nix configs, secrets ACLs, GitHub access

{
  name = "you";
  email = "you@company.org";
  sshKeys = [ "ssh-ed25519 AAAAC3..." ];
  roles = [ "founder" "platform" ];
}


⸻

8. Policies (Access / Security / Governance)
	•	Format: OPA/Rego policies, IAM JSON, or Nix expressions
	•	Location: /infra/policies/
	•	Examples: Who can approve CI deploys, which tasks require 2FA

package deploy

allow {
  input.user in ["you"]
  input.repo == "services/api"
}


⸻

9. Metrics & Alerts
	•	Tool: Prometheus, Alertmanager
	•	Defined in: /infra/observability/prometheus.rules
	•	Example:

groups:
  - name: api
    rules:
      - alert: ApiLatencyHigh
        expr: http_request_duration_seconds_mean > 0.5
        for: 2m


⸻

10. Runbooks & Documentation
	•	Format: Markdown + embedded commands
	•	Stored in: /docs/runbooks/
	•	Standard fields:
	•	Context
	•	Trigger condition
	•	Command sequence
	•	Verification step
	•	Rollback step

⸻

11. Datasets
	•	Location: /data/schema/, /data/snapshots/
	•	Storage: S3 with immutability locks
	•	Metadata: Schema, partitioning, retention policy

name: events
format: parquet
partition: daily
retention: 180d


⸻

12. Automated Jobs (Cron, Triggers)
	•	Location: /services/api/cronjobs.nix or /jobs/
	•	Scheduled via: Kubernetes CronJobs or systemd timers
	•	Declared as Nix:

{
  cron = "* * * * *";
  command = "nix run .#cleanup-task";
}


⸻

13. Governance
	•	Format: Pull requests + votes + GPG signatures
	•	Stored in: /governance/
	•	Used for: Org-wide changes, policies, permanent structure

⸻

III. Interaction Model

The primitives are not siloed—they form a linked operational graph.
	•	Tasks link to epics
	•	Epics link to pipelines
	•	Pipelines output artefacts
	•	Artefacts get deployed to hosts
	•	Hosts load users and secrets
	•	Secrets reference people and policies
	•	Observability probes the running artefacts
	•	Docs explain the tasks and artefacts
	•	Signals and alerts route to communication systems
	•	Governance modifies the constraints of the above

No object is unmanaged. Every interaction is versioned. Every state is reproducible.

⸻

IV. Why This Works

Because:
	•	No hidden state exists. Everything is inspectable.
	•	Drift is impossible. All state change flows through review.
	•	Recovery is trivial. Systems can be rehydrated exactly from Git + binary cache.
	•	Scale is linear. 1 user or 10,000—same primitives, same contracts.

⸻

V. Conclusion

These primitives are the DNA of your deterministic organisation.
You model them now—imperfectly, minimally, manually—but you never step outside of them.

That’s the contract:
If it matters, it’s a primitive.
If it’s not a primitive, it doesn’t matter.