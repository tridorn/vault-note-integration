---
owner: Ben Jendyk
id: dfb80597-e721-4548-a374-5855e6421df5
created: 2025-08-13T17:45:48+0200
modified: 2025-08-13T17:45:49+0200
tags: [access/public, language/en]
key-words: []
aliases: [Adoption plan that actually sticks]
title: Adoption plan that actually sticks
---

You should have asked: "Outline concrete adoption steps, governance controls, and licensing choices to operationalise the repository taxonomy across my organisation."

  

# Adoption plan that actually sticks

1. Executive mandate and scope

  

- Name a single accountable owner for standards. Publish scope: which teams and repos are in phase 1.
- Decide monorepo vs polyrepo for each domain now; do not "re-evaluate later".

  

2. Templates and automation first

  

- Ship template-* repos and reusable CI workflows before enforcement. People must have an easy default.
- Provide a one-command scaffolder, e.g. bootstrap-new-repo.sh --type svc --name auth.

  

3. Codify guardrails in the platform

  

- Organisation-level GitHub settings: default branch protection, required reviews, required status checks, secret scanning, code scanning, Dependabot, signed commits, default labels and issue templates.
- Repos created only via a provisioning script that applies these defaults and registers CODEOWNERS.

  

4. Inventory and categorisation

  

- Crawl all existing repos. Attach labels: category, owner, lifecycle. Produce a public index in handbook.
- Identify split targets: mixed concerns, no owner, large binary history.

  

5. Migration waves

  

- Wave 1: extract scripts into ops-*, centralise CI to automation-github.
- Wave 2: promote shared logic to lib-*, add SemVer and publish.
- Wave 3: infra split into infra-*, add policy checks.
- Wave 4: deprecate or archive unowned or stale repos with tombstone READMEs.

  

6. Enforcement after escape hatches exist

  

- Block merges lacking CODEOWNERS, README, LICENSE, SECURITY, CONTRIBUTING.
- Require central CI workflow reference; forbid bespoke pipelines without exception ticket.

  

7. Operating rhythm

  

- Monthly standards review. Rotating "standards czar" closes loopholes.
- Quarterly repo health audit with metrics below.

  

# Governance controls that matter

- Ownership: exactly one accountable team per repo in CODEOWNERS; deputies listed. No owner means no production deploys.
- Lifecycle labels: incubating, active, maintenance, deprecated, archived. Changes require PR and changelog entry.
- Change control:

    - Services and libraries: SemVer, release PR template, SBOM and provenance on release.

    - Infra: planfile attached to PR, policy-as-code gates, change request ID in commit.

    - Ops scripts: date-based tags and required --dry-run for destructive actions.
- Security baselines:

    - Organisation secrets manager only; zero long-lived personal tokens.

    - Pre-commit secret scans; server-side secret scanning required.

    - Mandatory dependency updates policy: auto PRs merged within SLA unless risk noted.

  

# Practical GitHub defaults (apply org-wide)

- Branch protection: 1+ code owner review, dismiss stale approvals on push, require linear history, require passing checks, block force-push to protected branches, require signed commits and signed tags.
- Required checks: lint, tests with coverage floor, SCA, secret scan, container scan for services, IaC policy checks for infra.
- Environments: dev, staging, prod with required reviewers on prod deploys.
- Issue/PR hygiene: templates for bug, feature, chore; PR template asks for category, release impact, ownership.

  

# Licensing strategy

  

Pick licenses by intent, patent posture, and dependency compatibility. Default to a small set to reduce legal surface.

- Internal-only, proprietary

    - License: private, standard copyright notice. No open-source license. Keep repos private. Consider source-available if sharing internally across subsidiaries.
- Public reusable libraries

    - Prefer Apache-2.0 if you want an explicit patent grant and defensive clarity.

    - Prefer MIT for maximal adoption where patent risk is low and you want minimal friction.

    - Prefer BSD-3-Clause if your ecosystem leans BSD; functionally similar to MIT.
- Copyleft posture

    - GPLv3 if you intend to force derivatives to open source; acceptable for tooling, risky for libraries.

    - AGPLv3 if you want network-copyleft; will deter adoption by many companies.

    - MPL-2.0 for file-level copyleft, pragmatic middle ground.
- Dual-licensing

    - For libraries where you want open adoption plus paid embedding rights, dual-license AGPLv3 + commercial. Requires Contributor License Agreement and clean IP tracking.
- Patents and CLAs

    - Use Apache-2.0 or add explicit patent license to contributor terms.

    - If accepting external contributions, adopt a Developer Certificate of Origin or a concise CLA.

  

Decision table:

- Max adoption, low legal overhead → MIT.
- Need patent grant and corporate comfort → Apache-2.0.
- Keep improvements open by design → GPLv3/AGPLv3.
- Balance copyleft with pragmatism → MPL-2.0.

  

# Minimal content standards per repo

- README with purpose, consumers, quickstart, support status, escalation path.
- LICENSE per above.
- SECURITY.md with contact, supported versions, disclosure policy.
- CONTRIBUTING.md with branch model, tests, release rules.
- CODEOWNERS with one accountable owner and deputies.
- Changelog: human-written, not auto-generated noise.

  

# CI/CD execution details

- Central workflows in automation-github. Repos only define a thin wrapper that pins a major version like uses: org/automation-github/.github/workflows/service@v1.
- On release:

    - Build, test, scan, SBOM, provenance attestations.

    - Publish packages/images. Tag vX.Y.Z and main-SHORTSHA.

    - Create GitHub Release with changelog section and artifacts.
- On pull request:

    - Run unit tests, static analysis, secret scan.

    - For services: ephemeral preview environment with URL; auto-destroy on merge/close.

    - For infra: plan + policy report attached; manual approval gates for prod.

  

# Secrets, keys, and compliance

- One secrets manager. No .env in repos. CI fetches short-lived credentials.
- Rotate credentials via automation; alarms on stale secrets.
- Audit logs enabled org-wide. External backups for audit evidence.
- Compliance mapping: maintain a simple matrix in handbook linking controls to CI checks and repo policies.

  

# Metrics that expose reality

- Coverage floor by category: libs ≥80, services ≥70, ops scripts smoke-tested.
- Dependency freshness: median time-to-merge Dependabot PRs.
- Security: number of high vulns >30 days old. Goal is zero.
- Hygiene: % repos with full required files and CODEOWNERS. Goal is 100.
- Bus factor: at least two maintainers per active repo.

  

# 30-60-90 day rollout

- Days 1--30: publish taxonomy, ship templates, create automation-github, turn on org security defaults, inventory and label repos, set up provisioning script.
- Days 31--60: migrate CI to central workflows, split top 10 mixed repos, add CODEOWNERS and required files everywhere, start release discipline on libraries/services.
- Days 61--90: enforce checks as mandatory, complete infra split with policy gates, archive dead repos, publish first quarterly health report.

  

# Migration mechanics that avoid drama

- Use read-only freeze windows when splitting repos. Preserve history with git filter-repo.
- Keep old repo as a stub with a tombstone README linking to successors for 90 days.
- Provide shims or adapter packages for moved libraries with deprecation warnings.
- For services, maintain both old and new pipelines for one release to reduce rollback risk.

  

# Decision rights and exceptions

- Standards owner approves exceptions with expiry dates. Exceptions live in standards/exceptions.md with rationale and planned removal date.
- No private forks. If work is sensitive, use private repos with the same standards.

  

# Low-friction tooling

- Pre-commit config shared via a small repo and referenced as a submodule or curl installer.
- A repo-linter script that checks for required files, labels, and CI references. Run weekly and post results.

  

# Practical defaults you can copy

- Libraries: Apache-2.0 default, SemVer releases, publish to registry, ≥80% coverage.
- Services: Apache-2.0, SemVer, container images with SBOM and provenance, runbook required.
- Ops scripts: private, date tags, dry-run flag required, smoke tests on critical paths.
- Infra: private, environment folders, plan+policy gates, no secrets in code.
- Templates: Apache-2.0, include central CI reference and security baseline.

  

Adopt these controls in the sequence above. You will compress onboarding time, reduce incident mean time to repair, and create a clean audit trail without adding ceremony where it does not pay.