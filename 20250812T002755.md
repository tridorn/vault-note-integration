---
owner: Ben Jendyk
id: 0a3ffde2-8a3f-4bc2-bcb4-8d0a65a44b4d
created: 2025-08-12T00:27:55+0200
modified: 2025-08-12T00:27:55+0200
tags: [access/public, language/en]
key-words: []
---

Correction: You should have asked: “How does Ansible compare to Terraform and Nix in terms of function, scope, and operational model?”

⸻

You’re referencing three declarative system tooling stacks with overlapping but distinct domains. Understanding how they differ—not just what they do—is key to applying the right one based on need, not hype.

⸻

I. Ansible – Procedural Configuration Management

What It Is:

A host-level configuration automation tool. You declare the desired state (e.g., “nginx should be installed and running”), and it executes tasks step by step over SSH.

Scope:
	•	Post-provision configuration
	•	Application setup, file management
	•	Agentless: only SSH + Python needed on the target

Execution Model:
	•	Procedural: executes top-down
	•	Imperative within declarative YAML
	•	Idempotent (tries not to repeat actions)

Example Use:

Configure 100 servers identically (users, packages, services) using one central playbook.

Strengths:
	•	Fast to adopt
	•	Highly flexible per-host logic
	•	Good for mutable systems

Weaknesses:
	•	Not fundamentally reproducible (system state drifts)
	•	Limited planning or diffing
	•	Weak dependency modeling

⸻

II. Terraform – Declarative Infrastructure Provisioning

What It Is:

An infrastructure provisioning tool. You describe cloud resources (VMs, networks, storage), and it ensures those resources exist exactly as described.

Scope:
	•	Cloud resources (AWS, GCP, Azure, etc.)
	•	Network infrastructure
	•	DNS, firewalls, Kubernetes clusters

Execution Model:
	•	Declarative: desired end-state
	•	Plan + Apply: preview before execution
	•	Resource graph resolution: parallelism, dependency tracking

Example Use:

Provision a VPC, load balancer, and three EC2 instances in AWS with exact versions and tags.

Strengths:
	•	True infrastructure-as-code with state management
	•	Modular and composable
	•	Predictable and auditable change plans

Weaknesses:
	•	Not for software configuration (can’t install nginx)
	•	Requires managing state files carefully
	•	Steep learning curve when scaled

⸻

III. Nix / NixOS – Functional, Purely Declarative System Definition

What It Is:

A package manager (Nix) and full declarative operating system (NixOS) using a functional language to define entire system states, including configuration, packages, and services.

Scope:
	•	System-wide config, packages, services
	•	User environments, dev shells, container images
	•	Reproducible software builds

Execution Model:
	•	Purely declarative + functional
	•	Immutable: every system state is a hash addressable store path
	•	Rollback, reproducibility, atomic upgrades

Example Use:

Define a file configuration.nix that describes everything about a system, then nixos-rebuild switch.

Strengths:
	•	Reproducibility is mathematically enforced
	•	Extreme control and rollback power
	•	Clean dev environments (nix-shell, nix develop)

Weaknesses:
	•	High complexity and steep learning curve
	•	Functional language is alien to most ops users
	•	Poor default UX

⸻

Direct Comparison Table

Feature	Ansible	Terraform	Nix / NixOS
Primary Use	Configuring machines	Provisioning infra	Defining entire systems
Execution Model	Procedural + idempotent	Declarative w/ planning	Pure functional declaration
Applies To	Existing hosts	Cloud APIs	OS, packages, environments
Agent Requirement	No	No	Yes (Nix installed)
Rollback Support	Manual	Partial via plan	Native, atomic
Reproducibility	Best-effort	High (infra)	Total
Learning Curve	Low	Medium	High
Where It Runs	Toolbox or host	Anywhere	Requires Nix
Output Granularity	Tasks	Resources	Derivations


⸻

Where Each Fits

Objective	Use Tool
Configure existing Linux servers	Ansible
Provision cloud resources	Terraform
Reproducible developer environments	Nix
Fully declarative OS configuration	NixOS
One-off setup automation	Ansible
Managing infrastructure state	Terraform
Immutable and rollbackable systems	Nix/NixOS


⸻

Strategic Summary:
	•	Ansible: Use when you control a fleet of machines and want to standardise or automate setup. Best for mutable infra.
	•	Terraform: Use when you control infrastructure or cloud topology. It creates systems; it doesn’t configure them.
	•	Nix/NixOS: Use when you want complete reproducibility and immutable state, including your personal dev tools.

Each one serves a different layer of the infrastructure stack. Use accordingly.