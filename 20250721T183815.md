---
owner: Ben Jendyk
id: <% tp.user.createUUID() %>
created: 2025-07-21T18:38:15+0200
modified: 2025-07-21T18:38:18+0200
tags: [access/public, language/en]
key-words: []
---

### Goal

You want **one‑click "block modules"** that drop _both_ halves of a mirrored section (Y A M L + body) into an existing note **without breaking anything**.
* * *

## 1 Key Obsidian / Templater facts

| Fact | How we'll exploit it | 
| ---- | ----  |
| **Templater can edit front‑matter programmatically**(`tp.file.set_frontmatter`, `tp.file.append_frontmatter`) | We can inject or update YAML keys even if some already exist. | 
| **Templater can insert body text at the cursor (or by searching for a marker)** | We can add the matching `## N …` section exactly once. | 
| **Nested templates & command palette shortcuts** | One command can call a "composite" template that handles _both_ layers. | 
* * *

## 2 Template architecture
    
    
    Templates/
    ├─ _core.md              ← full new‑note scaffold (metadata + body #1 Core)
    ├─ blocks/
    │   ├─ flow.md           ← JS logic to update flow block + body section
    │   ├─ taxonomy.md
    │   ├─ links.md
    │   └─ content.md        …etc.
    └─ partials/
        ├─ body-flow.md      ← pure markdown section (no YAML)
        └─ body-taxonomy.md
    

### Why two folders?

- `blocks/` = **hybrid** templates (YAML **and** body).
- `partials/` = **body‑only** snippets (used by the hybrids).
* * *

## 3 What happens under the hood (example: `blocks/flow.md`)

1. **YAML side**
    
        <%*
      const fm   = tp.frontmatter;
      const flow = fm["flow"] ?? {};
      flow.stage   = flow.stage   ?? "capture";
      flow.status  = flow.status  ?? "idea";
      flow.project = flow.project ?? null;
      tp.file.set_frontmatter({...fm, flow});
    %>
    

2. **Body side**  
_Insert once, right after the last mirrored section already present_:
    
        <%*
      const marker = /^##\s\d+\s[\w ]+/gm;
      const body   = await tp.file.read();
      const count  = [...body.matchAll(marker)].length;
      const nextNo = count + 1;
      const section = await tp.file.include("[[partials/body-flow.md]]");
      await tp.file.cursor_end();
      await tp.file.insert(`\n\n## ${nextNo} Flow\n${section}`);
    %>
    

Result → YAML updated _or created_, body gains:
    
    
    ## N Flow
    | Stage | Status | Project | Sprint | Due |
    |-------|--------|---------|--------|-----|
    | capture | idea | -- | -- | -- |
    

_(Exactly once--script checks before inserting.)_

* * *

## 4 Daily workflow

| Scenario | What you do | Behind the scenes | 
| ---- | ---- | ----  |
| **New note** | `⌘P → Core template` | Creates full core YAML + `## 1 Core`body skeleton. | 
| **Decide to plan** | `⌘P → Flow template` | Adds/updates YAML `flow` + injects `## 2 Flow` body section. | 
| **Need taxonomy** | `⌘P → Taxonomy template` | Same pattern; becomes `## 3 Taxonomy`. | 
| **Change stage later** | Re‑run _Flow_ template **or** use a QuickAdd form that edits `flow.stage` only; body table updates automatically. |  | 

_Because each hybrid template checks for existing keys & headings, it's **idempotent**--running it twice just updates values._

* * *

## 5 Advantages vs. "two separate templates"

| Two‑template idea | Hybrid‑block approach | 
| ---- | ----  |
| Risk of forgetting one half | Single command guarantees parity | 
| Hard to keep numbering right | Hybrid knows how many sections already exist | 
| YAML collisions possible | Code merges dictionaries safely | 
| More shortcuts to remember | One per block (same as conceptual model) | 

* * *

## 6 Getting started fast

1. **Copy** the directory structure above into `Templates/`.

2. **Map** each `blocks/*.md` template to a command‑palette alias (or a QuickAdd choice):

    - "Add Flow block" → `Templates/blocks/flow.md`

    - "Add Links block" → `Templates/blocks/links.md`

3. **Create** the `_core.md` template (full new‑note scaffold) and set it as your default New Note template in Templater settings.

4. **(Optional)** make a _"Smart promote to Library"_ template that:

    - moves the note to `80_Library/`

    - calls `blocks/taxonomy.md`, `blocks/links.md`, `blocks/content.md` in sequence.
* * *

## 7 If you prefer _even less_ scripting

- Keep **Core** template simple (YAML + `## 1 Core`).
- Make **body‑only** partials for each section.
- Use **Dataview inline fields** in body tables instead of touching YAML (but then you lose strict mirroring).

The hybrid method is just the least error‑prone over time.

* * *

### TL;DR

**Create one hybrid template per block** (`blocks/flow.md`, `blocks/taxonomy.md`, …).  
Each hybrid script updates / inserts the YAML keys _and_ injects the matching body section _exactly once_, renumbering automatically.  
Run those templates ad‑hoc from the command palette or bundle them into composite "purpose" templates--mirroring stays perfect, nothing gets duplicated, and you never have to remember two separate snippets.