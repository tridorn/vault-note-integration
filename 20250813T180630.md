---
owner: Ben Jendyk
id: 2d990cdd-5fb5-4824-b236-a7fbd207667f
created: 2025-08-13T18:06:30+0200
modified: 2025-08-13T18:06:31+0200
tags: [access/public, language/en]
key-words: []
---

You should have asked: "Provide a reference architecture diagram and lifecycle flows for a provider-independent company built on Git/S3/Postgres with HTTP and an event bus as the unifying layer, including identity, control plane, and human interfaces."

* * *

## 1. Reference architecture -- component view
    
    
    +--------------------------------------------------------------+
    |                      Presentation Layer                     |
    |                                                              |
    |  Web Portals  |  CLI  |  Slack/Matrix Bot  |  Reports UI     |
    |   (HR, Ops)   |       |                   |                  |
    +--------------------------------------------------------------+
                    |            |                |
                    v            v                v
    +--------------------------------------------------------------+
    |                       Control Plane API                      |
    |    (HTTP/REST/GraphQL endpoints for all core systems)        |
    |                                                              |
    |  /git/...    /storage/...    /db/...    /identity/...        |
    |                                                              |
    +--------------------------------------------------------------+
                    |                              ^
                    v                              |
    +--------------------------------------------------------------+
    |                  Event Bus / Message Backbone                |
    |         (Kafka/NATS, JSON schemas for all event types)       |
    +--------------------------------------------------------------+
         |                  |                        |
         v                  v                        v
    +---------+    +----------------+      +------------------+
    |   Git   |    |   Object Store  |      |   Postgres DB    |
    | (code,  |    | (S3 API,        |      | (SQL, schemas)   |
    |  docs,  |    |  binaries, data)|      |                  |
    +---------+    +----------------+      +------------------+
         |                  |                        |
         v                  v                        v
    +--------------------------------------------------------------+
    |                  Execution / Automation Layer                |
    |    (CI/CD runners, provisioning scripts, report generators)  |
    +--------------------------------------------------------------+
                    ^
                    |
    +--------------------------------------------------------------+
    |                     Identity & Access Layer                  |
    | (OIDC IdP, RBAC policies in Git, access provisioning scripts)|
    +--------------------------------------------------------------+

* * *

## 2. Lifecycle flows

  

### 2.1 Technical change (service update)

1. Developer commits to code-auth repo (Git).

2. Git webhook → Control Plane API emits repo.updated event to event bus.

3. CI runner consumes event, builds artifact, uploads binary to S3.

4. CI updates infra-auth repo with new deploy manifest.

5. Merge triggers deploy job (via Control Plane → infra orchestrator).

6. Event bus emits service.deployed → monitoring system updates status.

  

Key traits:

- All actions observable via event bus.
- All artifacts traceable: Git SHA → S3 object hash → deployed service.
* * *

### 2.2 HR onboarding

1. HR edits org-structure.yaml in org-structure repo (Git).

2. Merge triggers org.employee.added event.

3. Provisioning script (listening on event bus) calls:

    - /identity/create-user (Control Plane API) → IdP.

    - /slack/add-user via integration bot.

    - /git/grant-access for relevant repos.

4. Slack bot sends onboarding checklist link (hosted in docs-onboarding repo).

  

Key traits:

- HR never touches IdP or Slack admin console directly.
- Git history provides HR decision audit.
* * *

### 2.3 Policy update

1. Security edits password-policy.md in docs-policies repo.

2. Merge → policy.updated event.

3. Notification system posts to Slack channels and sends email.

4. HR portal fetches updated policy via /git/file API for display.

  

Key traits:

- Same change visible to developers, HR, and external auditors.
- Event bus ensures real-time propagation.
* * *

## 3. Unifying layer mechanics

- HTTP API

Every core system (Git, S3, Postgres, IdP) is abstracted behind REST or GraphQL endpoints with consistent authentication (OIDC).

Example calls:
    
    
    POST /git/repo/{name}/commit
    GET /storage/object/{id}
    POST /db/query
    POST /identity/assign-role

-   
- Event bus

All significant changes publish structured JSON events:
    
    
    {
      "event": "org.employee.added",
      "timestamp": "...",
      "payload": { "employee_id": "...", "role": "developer" }
    }

- Consumers subscribe based on domain: CI listens for repo.updated, HR automation listens for org.*, analytics listens for *.
* * *

## 4. Identity and access control

- Central OIDC provider (Keycloak, etc.).
- RBAC policies stored as YAML in infra-identity repo; merges trigger /identity/update-roles.
- Same identity used for:

    - Git commit signing.

    - API authentication.

    - S3/DB access.
- Role examples:

    - developer: push to code repos, read object storage, run CI jobs.

    - operator: manage infra repos, trigger deploys.

    - hr: manage org repos, run HR automations.

    - auditor: read-only access to all.
* * *

## 5. Why this works long-term

- Provider independence:

Replace Git backend (GitHub → GitLab), object store (AWS S3 → MinIO), or database (Postgres → CockroachDB) without altering workflows -- API and event contracts remain stable.
- End-to-end auditability:

Any state in the company can be reconstructed by replaying Git history and object store versions.

- Human--machine parity:

Non-technical UIs are thin wrappers over the same API; no hidden admin consoles with untracked state.

- Decoupling:

Event bus removes direct tool-to-tool dependencies; services can evolve independently.

* * *

If you want, I can now break down the minimal standard specifications for each interface (HTTP endpoints, event schema, storage conventions) so this is implementation-ready without locking into specific products. That would make the system portable across vendors and auditable by design.