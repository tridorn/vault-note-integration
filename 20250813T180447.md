---
owner: Ben Jendyk
id: 27b606b9-0d84-4371-bca1-13fce2364b06
created: 2025-08-13T18:04:47+0200
modified: 2025-08-13T18:04:48+0200
tags: [access/public, language/en]
key-words: []
---

You should have phrased this as: "Assess the feasibility of running an entire company on a provider-independent, standards-based substrate, identify the unifying operational layer, and define the architectural model that supports both technical and non-technical functions."

* * *

## 1. Does the model work as stated?

  

It works in principle but only if you accept trade-offs:

- Pros

    - Tool independence is possible because protocols (Git, S3 API, SQL, HTTP) are well-established and have multiple implementations.

    - All assets (code, data, processes) become versioned and reproducible.

    - Vendor changes become mostly endpoint/config swaps, not rewrites.
- Constraints and failure points

    - Discipline is the weak link. Without a governance body, people will bypass canonical flows ("I just sent it on Slack" → lost in 48h).

    - Latency: A fully standardised model avoids proprietary integrations, but that means building more glue code. Expect slower delivery of features compared to vendor lock-in.

    - Complexity creep: Multiple interchangeable backends require consistent API compatibility testing. Even with "standards," implementations differ subtly.

    - Cultural inertia: For non-technical functions (HR, finance, legal), pushing them into Git workflows and schema-validated docs is a learning curve.

  

Verdict: Achievable, but it will feel slower in the first year until the org culture normalises around the rails.

* * *

## 2. What is this company "based on"?

  

At the core, this model makes the company an information logistics network where every asset is addressable, versioned, and retrieved via open interfaces.

  

The underlying substrate is:

1. Storage standards

    - Git (any implementation) for small, structured, and text-based data.

    - S3 API for large/binary data.

    - SQL (Postgres dialect) for structured operational datasets.

2. Access & orchestration standards

    - HTTP/HTTPS for programmatic access across all components (REST or RPC-over-HTTP).

    - Event streaming (OpenTelemetry, syslog, Kafka API) for system-to-system notifications.

3. Identity & security standards

    - OAuth 2.0 / OIDC for authentication.

    - Role-based access control (RBAC) defined centrally, enforced everywhere.

  

Essentially, the "company" is based on content-addressable versioned stores with network-accessible APIs and a universal identity layer.

* * *

## 3. Unifying operational layer

  

Yes, you need a single control plane for the human and machine interfaces. Without it, you end up with isolated Git repos, S3 buckets, and databases with no coherent workflow.

  

Options:

- HTTP as the unifying call surface:

Every action (commit, file upload, query, job trigger) is an HTTP request to a known endpoint.

    - Examples: POST /git/commit, GET /s3/object, POST /db/query.

    - Works because HTTP is universal, easy to proxy, and allows simple auth via OIDC.
- Event bus as the backbone:

Every change emits an event with a schema (e.g., JSON over Kafka or NATS).

    - This allows decoupled processing: HR update in Git triggers access revocation, infra repo change triggers deploy pipeline.

  

Rational choice: Use HTTP for direct actions and an event bus for reactive flows. HTTP is the human-facing control API; the bus is the machine-facing automation trigger.

* * *

## 4. Architectural model for the company

  

### 4.1 Physical and logical layers

1. Data layer

    - Git servers (mirrored)

    - Object storage (S3 API)

    - Postgres (clustered, high-availability)

2. Control plane

    - API Gateway that exposes all Git, S3, and DB actions over HTTP.

    - Event bus (Kafka/NATS) connected to every major system.

3. Execution layer

    - CI/CD runners that pull from Git, fetch from S3, push to Postgres, and emit events.

    - Automation bots triggered by events (infra deploys, HR account changes, reporting).

4. Identity layer

    - Central OIDC provider (Keycloak, Auth0, etc.).

    - Role definitions stored in Git; provisioning scripts push changes to the IdP.

5. Presentation layer

    - Web dashboards for non-technical staff (HR, finance) that operate purely via the HTTP API, not direct DB or Git access.

    - Slack/Matrix integration: chat commands trigger API calls.
* * *

### 4.2 Flow examples

- Technical change:

Developer commits to Git → CI pipeline builds artifact → stores binary in S3 → updates deploy manifest in infra repo → merge triggers deploy job → emits "service.updated" event.

- HR onboarding:

HR updates org-structure.yaml in Git → event triggers account provisioning script → creates user in IdP, adds to Slack, gives repo access → sends onboarding checklist via Slack bot.

- Policy update:

Security officer edits password-policy.md in docs-policies → merge triggers notification to all employees → HR portal shows updated version (pulled from Git via HTTP).

* * *

## 5. Implementation reality check

- The HTTP + event bus dual layer keeps systems loosely coupled but still orchestrated.
- Every system in the company becomes replaceable so long as it speaks the agreed APIs.
- The hardest part is governance and discipline, not technology. Without strict enforcement (bots, CI gates, quarterly audits), people revert to ad-hoc processes.
* * *

## 6. Strategic implications

- This company becomes process-first, tool-second.
- Switching cloud providers, storage systems, or CI tools is low-risk.
- The entire operational graph is auditable and replayable: you can reconstruct the state of the org from the Git history and object storage at any point in time.
- Non-technical staff work in tailored UIs, but those UIs are thin wrappers over the same APIs developers use.
* * *

If you want, I can outline the full reference architecture diagram and lifecycle flows for such a company, showing Git/S3/Postgres as the backbone, the HTTP API + event bus as the unifying layer, and role-based identity as the control fabric. That would make the concept concrete enough to hand to engineers and operations simultaneously.