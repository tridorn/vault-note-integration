---
owner: Ben Jendyk
id: 97bbb1e3-f4b7-4155-b722-f0a1756272bb
created: 2025-08-13T17:40:32+0200
modified: 2025-08-13T17:40:34+0200
tags: [access/public, language/en]
key-words: []
aliases: [Principles that govern the structure]
title: Principles that govern the structure
---

You should have asked: "Decompose the repository taxonomy into concrete categories with purpose, context, inclusion/exclusion rules, ownership, risks, and decision consequences, so I can sort all present and future code with minimal ambiguity."

  

# Principles that govern the structure

- Minimise coupling, maximise reuse. One concern per repo. Cross-links via packages, APIs, or workflows.
- Default to small, purpose-built repos. Monoliths accumulate debt; split when ownership or lifecycle diverges.
- Repos are products. Each has a defined consumer, release model, SLO for maintenance, and a single accountable owner.

  

# Categories, with context and hard boundaries

  

## 1) Operational scripts

  

Name pattern: ops-<domain>-scripts

Purpose: glue and maintenance tasks that orchestrate other systems.

Context: invoked by humans or schedulers; should be idempotent and safe to re-run.

Include: migration helpers, backup/restore, log rotation, admin one-offs that recur, cron jobs, data fixes.

Exclude: long-running daemons; reusable libraries (extract shared helpers to /scripts/lib or a proper lib-…).

Consumers: SREs, operators, CI.

Risks if misclassified: buried in app repos, they rot and break after dependency changes.

Success metrics: time-to-runbook (<2 min), dry-run available, exit codes reliable.

Minimal layout:
    
    
    /scripts/<topic>/<name>.(sh|py|ps1)
    /scripts/lib/
    /tests/ (smoke tests)
    /Taskfile.yml or Makefile

Release model: date tags, e.g. 2025.08-maintenance.

Ownership: team operating the affected domain.

  

## 2) Reusable libraries (packages)

  

Name: lib-<lang>-<domain>

Purpose: stable APIs reused across multiple projects.

Context: versioned, published to a registry; backward compatibility matters.

Include: client SDKs, domain utilities, shared validation, protocol codecs.

Exclude: executables, environment-specific configuration.

Consumers: services, scripts, notebooks.

Risks: "grab-bag" libs with mixed concerns; breaking changes without SemVer discipline.

Success: >2 dependents, SemVer, changelog, >80% unit coverage.

Layout:
    
    
    /src/<pkg>/
    /tests/
    /examples/
    /pyproject.toml|package.json|...

Release: SemVer, automated publish.

Ownership: domain owners; publish rights limited.

  

## 3) Services (APIs, daemons, CLIs as products)

  

Name: svc-<name>

Purpose: always-on functionality with SLOs or a distributable CLI that acts like a product.

Context: observable, deployable artifact (container, binary).

Include: web APIs, event consumers, schedulers with service guarantees, serious CLIs.

Exclude: short scripts, experiments.

Consumers: users, other services, jobs.

Risks: tight coupling to infrastructure, no runbook, opaque deploys.

Success: health checks, dashboards, runbook, rollbacks tested.

Layout:
    
    
    /cmd/<binary>/
    /internal/ or /src/
    /configs/
    /deploy/ (helm, k8s manifests, terraform module refs)
    /tests/unit, /tests/integration
    /docs/runbook.md

Release: SemVer, images tagged vX.Y.Z + main-SHORTSHA.

Ownership: product team with on-call.

  

## 4) Infrastructure-as-Code

  

Name: infra-<scope> (e.g. infra-network, infra-k8s)

Purpose: declarative environments and policies.

Context: changes create or mutate shared resources; strict review.

Include: Terraform, Pulumi, Helm charts if central, OPA/Sentinel policies.

Exclude: app code; environment secrets in plaintext.

Consumers: platform teams, services.

Risks: drift, snowflake resources, hidden dependencies.

Success: plan diffs clean, policy checks green, drift zero.

Layout:
    
    
    /envs/dev|staging|prod/
    /modules/
    /policies/
    /pipelines/

Release: environment-locked; change tickets linked.

Ownership: platform/infra team.

  

## 5) Automation pipelines and CI/CD building blocks

  

Name: automation-<platform> (e.g. automation-github, automation-airflow)

Purpose: reusable workflows, DAGs, pipeline libraries.

Context: referenced by many repos; versioned centrally.

Include: composite GH Actions, Airflow DAGs, reusable CI templates, shared CI scripts.

Exclude: repo-specific YAMLs (keep those minimal and reference central ones).

Consumers: all repos.

Risks: copy-pasted workflows drift; security gaps.

Success: >70% of repos reference central workflows; incident rollouts via single change.

Layout:
    
    
    /workflows/ or /dags/
    /lib/
    /tests/

Release: SemVer tags (v1, v2), breaking changes documented.

Ownership: DevEx/Platform.

  

## 6) Data science, analysis, and experiments

  

Name: lab-<topic> for explorations, report-<topic> for published results.

Purpose: fast iteration vs. fixed deliverables.

Context: reproducibility and provenance matter more than polish.

Include: notebooks, experiment scripts, feature exploration, finalized reports.

Exclude: production ETL (goes to services or automation).

Consumers: analysts, stakeholders.

Risks: data leakage, irreproducible results, notebooks as production.

Success: pinned env, seeds fixed, data paths abstracted via DVC or similar.

Layout:
    
    
    /notebooks/
    /src/
    /data/ (gitignored; pointers only)
    /models/ (tracked via MLflow/DVC)
    /reports/ (for "report-...")

Release: stamped report versions; experiments are disposable with clear dates.

Ownership: data team or author.

  

## 7) Templates and scaffolds

  

Name: template-<stack>

Purpose: codify a blessed starting point.

Context: used via Copier/Cookiecutter or a bootstrap script; aggressively opinionated.

Include: minimal working example, CI reference, security baseline, docs skeleton.

Exclude: business logic.

Consumers: anyone creating new repos.

Risks: divergence if templates aren't maintained.

Success: >80% of new repos bootstrapped from templates; time-to-first-green-build <10 min.

Release: tag templates; note breaking changes.

  

## 8) Dotfiles and devcontainers

  

Name: dotfiles, devcontainer-<lang>

Purpose: reproducible developer environments.

Context: reduces "works on my machine" variance.

Include: shell config, editor profiles, devcontainer definitions.

Exclude: secrets and personal tokens.

Consumers: all developers.

Risks: hidden global tweaks causing CI divergence.

Success: onboarding time reduced, CI parity.

  

## 9) Org-wide policy, standards, and handbook

  

Name: handbook, standards

Purpose: single source for rules and conventions.

Context: stable pages referenced by all repos.

Include: coding standards, review rules, security policy, release process, incident guides.

Exclude: team chatter; ephemeral notes.

Consumers: entire org.

Risks: outdated guidance; shadow policies.

Success: PR templates and CI link here; conflicts resolved centrally.

Release: version documents; PRs required for changes.

  

# How to decide what repo to create

- Scope is short-lived glue or operator task → ops-…-scripts.
- Code reused by 2+ projects with stable API → lib-….
- Always-on functionality or CLI with users → svc-….
- Provisioning or policies → infra-….
- Shared CI/DAGs → automation-….
- Exploration vs. publication → lab-… vs. report-….
- Starting point to clone → template-….
- Environment parity → dotfiles, devcontainer-….
- Rules and norms → handbook, standards.

  

# What goes in every repo, without exception

- README.md: purpose, consumers, quickstart, support status, escalation path.
- LICENSE and SECURITY.md.
- CODEOWNERS: one accountable owner, at least one deputy.
- CONTRIBUTING.md: branching, testing, release rules.
- Reusable CI reference, not bespoke pipelines.
- Pre-commit hooks for linting and secret scanning.

  

# Branching, versioning, and environments

- Trunk-based development with short-lived feature branches; protected main.
- Versioning by type: services and libraries use SemVer; scripts and notebooks use date tags; infra ties to environment change requests.
- Config is environment-driven; no code forks per environment.

  

# Population strategy to fix your current estate

1. Inventory and tag. Label each existing repo with a category and lifecycle: incubating, active, maintenance, deprecated, archived.

2. Split by lifecycle. If a repo contains both scripts and an app, extract scripts into ops-…. If libraries live inside services, promote to lib-….

3. Introduce templates. Create template-* repos matching the archetypes. From now on, new code starts there.

4. Centralise CI. Build automation-github and replace bespoke YAML with references. One place to patch security.

5. Establish ownership. Fill CODEOWNERS everywhere. No owner, no production.

6. Secrets and size hygiene. Move secrets to a manager; enforce size limits and LFS/DVC for large artifacts.

7. Backfill releases. Tag current versions according to category rules; write first CHANGELOG.md.

8. Index and discoverability. A nightly job publishes an index page in handbook listing repos, category, owner, lifecycle, latest release.

  

# Enforcement and signals

- Gate merges on: lint, tests, SCA, secret scan. Services add container scan and SBOM. Infra adds policy checks and plan approval.
- Require runbooks for services; require dry-run for critical scripts.
- Sunset policy: 90 days without owner or successor identified → mark deprecated, then archived with a tombstone README linking the replacement.

  

# Anti-patterns to avoid

- "Kitchen-sink" repos mixing app, infra, and scripts. Split by concern.
- Forked config per environment. Use one codepath with config overlays.
- Private logic hidden in CI YAML. Put logic in automation-… or scripts.
- Notebooks as production. Promote to services or scheduled jobs before relying on them.

  

# Quick starter templates (copy as defaults)

  

Library
    
    
    /src/<pkg>/
    /tests/
    /docs/
    /.gh/workflows/reuse.yml
    /pyproject.toml or package.json
    CHANGELOG.md

Service
    
    
    /cmd/<binary>/
    /internal/ or /src/
    /configs/
    /deploy/
    /tests/unit
    /tests/integration
    /docs/runbook.md
    CHANGELOG.md

Ops scripts
    
    
    /scripts/<topic>/
    /scripts/lib/
    /tests/
    /Taskfile.yml
    CHANGELOG.md

Infra
    
    
    /envs/dev|staging|prod/
    /modules/
    /policies/
    /pipelines/
    /docs/operating.md

# Consequences of adopting this model

- Faster onboarding and incident response; owners and runbooks are obvious.
- Cheaper change management; central CI gives one lever for security fixes.
- Cleaner evolution; libraries and services can version independently, scripts don't pretend to be products.
- Predictable deprecation; consumers can migrate with clear signals.

  

Adopt the taxonomy as written. Start with the inventory and split step; the rest follows.