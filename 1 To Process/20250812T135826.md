---
owner: Ben Jendyk
id: <% tp.user.createUUID() %>
created: 2025-08-12T13:58:26+0200
modified: 2025-08-12T13:58:29+0200
tags: [access/public, language/en]
key-words: []
aliases: [What to ship as templates]
title: What to ship as templates
---

Great question. There isn't one "right" way to template this--but there is a way that stays universal, simple, and scalable.

  

Here's a rational take on the three options you mentioned, plus a concrete, low‑friction way to implement the unified system in Obsidian.

  

# What to ship as templates

  

## Option A -- One mega‑template with

## all

##  blocks

  

Pros: perfect uniformity; easy to query; zero "missing block" surprises.

Cons: lots of empty sections; cognitive noise; higher maintenance; people stop filling things in.

  

Verdict: works for highly regimented teams, but overkill for a personal system. You'll get template fatigue.

* * *

## Option B -- Bare‑bones default, populate dynamically

  

Pros: fast to start; stays lean; only what's needed appears.

Cons: order and naming can drift; you'll need discipline and automation to guarantee symmetry (YAML ↔ H2).

  

Verdict: great ergonomics, but requires guardrails to keep the structure uniform.

* * *

## Option C -- Hybrid (recommended)

  

Ship a core spine in every note, then add atomic blocks on demand, and allow type overlays (project, book, paper) to pre‑add the most likely blocks.

- Core spine (always present): identity, intent, sources, content, conclusions, state, links.
- On‑demand atoms: inputs, method, findings, next, ledger.
- Type overlays: "Project" adds method, findings, next, ledger; "Book" adds findings and maybe trims method; "Paper" adds method + findings.

  

This keeps universality, reduces clutter, and still supports action‑heavy notes.

* * *

# How to implement (practical, durable)

  

## 1) Use three layers of templates

- Spine template (1 file): the always‑on seven blocks, with YAML + matching H2s.
- Atomic block snippets (one per block): each snippet adds the YAML subtree if missing, and inserts the matching H2 section (dual‑purpose).
- Type overlays (optional): small templates that insert the spine and then immediately insert a short list of atomic blocks in a fixed order.

  

> Tooling: you can do this with Templater + QuickAdd (or your snippet tool of choice). Keep atoms tiny and idempotent (safe to run twice without duplication).
* * *

## 2) Keep the dual‑purpose contract enforceable

- Naming: block names match exactly between YAML and H2 (## findings ↔ findings:).
- Idempotence: before inserting, each atom checks "does this YAML path exist?" If yes, don't add; if no, add keys with empty values.
- Mirroring: at the top of each H2, render a compact Dataview summary of the block's meta (read‑only), then your narrative/prose follows.
- Single point of truth: you write facts to YAML; the body is for meaning and prose.
* * *

## 3) Suggested spine (unified model)

  

YAML (top of note)
    
    
    identity:
      id: <% tp.date.now("YYYYMMDD-HHmmss") %>-<% tp.file.title.toLowerCase().replace(/[^a-z0-9]+/g,"-") %>
      title: <% tp.file.title %>
      type: note
    
    intent:
      purpose: ""
      questions: []
      outcome: ""
    
    sources:
      items: []   # [{id, title, author, year, doi|isbn, url}]
    
    content:
      mode: summary
      template: ""
    
    conclusions:
      claims: []
      decision: ""
      rationale: ""
    
    state:
      stage: capture
      status: open
      project: ""
      tags: []
      priority: normal
      created: <% tp.date.now("YYYY-MM-DD") %>
      updated: <% tp.date.now("YYYY-MM-DD") %>
    
    links:
      parent: ""
      children: []
      depends_on: []
      related: []

Body (H2s, in this fixed order)
    
    
    ## identity
    > ```dataview
    > TABLE identity.type, identity.id
    > WHERE file.path = this.file.path
    > ```
    <1--2 sentence definition.>
    
    ## intent
    > ```dataview
    > TABLE intent.purpose, intent.questions, intent.outcome
    > WHERE file.path = this.file.path
    > ```
    <Why this note exists; success conditions.>
    
    ## sources
    > ```dataview
    > TABLE WITHOUT ID items.title AS Title, items.author AS Author, items.year AS Year
    > FROM this
    > FLATTEN sources.items AS items
    > ```
    <Your take on coverage, biases, credibility.>
    
    ## content
    <The core body. Summary/analysis/draft--this is the main piece.>
    
    ## conclusions
    > ```dataview
    > TABLE conclusions.claims, conclusions.decision
    > WHERE file.path = this.file.path
    > ```
    <Your interpretation, takeaways, or decision.>
    
    ## state
    > ```dataview
    > TABLE state.stage, state.status, state.project, state.tags
    > WHERE file.path = this.file.path
    > ```
    <Nuance not captured by fields.>
    
    ## links
    > ```dataview
    > TABLE links.parent, links.children, links.depends_on, links.related
    > WHERE file.path = this.file.path
    > ```
    <Network narrative: how this connects, risks from dependencies.>

(Adjust Templater bits if you use another tool--idea is the same.)

* * *

## 4) Atomic block snippets (idempotent)

  

### a)

### block-method

  

What it does: adds method: to YAML if missing; inserts ## method H2 with a tiny mirror.
    
    
    <%* if (!tp.frontmatter.method) { await tp.file.insert_frontmatter("method", {approach:"", steps:[], tools:[], when:""}); } %>
    
    ## method
    > ```dataview
    > TABLE method.approach, method.steps, method.tools, method.when
    > WHERE file.path = this.file.path
    > ```
    <Explain the approach (reading, analysis, build).>

### b)

### block-findings
    
    
    <%* if (!tp.frontmatter.findings) { await tp.file.insert_frontmatter("findings", {statements:[], quotes:[], artifacts:[], metrics:{}}); } %>
    
    ## findings
    > ```dataview
    > TABLE findings.statements, findings.quotes, findings.metrics
    > WHERE file.path = this.file.path
    > ```
    <Interpretation of highlights/observations.>

### c)

### block-next
    
    
    <%* if (!tp.frontmatter.next) { await tp.file.insert_frontmatter("next", {action:"", owner:"", due:"", backlog:[]}); } %>
    
    ## next
    > ```dataview
    > TABLE next.action, next.owner, next.due
    > WHERE file.path = this.file.path
    > ```
    <Single next action OR main open question, with context.>

(If your tool can't mutate YAML, use MetaEdit or paste the stub once and rely on the properties UI afterward.)

* * *

## 5) Type overlays (compose, don't fork)

  

Create tiny overlays that: (1) insert the spine, (2) immediately insert a set of atoms, (3) set a couple of defaults.

  

Project overlay

- Sets identity.type: project, state.stage: clarify, content.mode: draft.
- Inserts atoms: method, findings, next, ledger.

  

Book overlay

- Sets identity.type: book, state.stage: done, content.mode: summary.
- Inserts atoms: findings (for highlights/quotes).

  

Paper overlay

- Sets identity.type: paper, content.mode: summary.
- Inserts atoms: method, findings.

  

Overlays are tiny--no new schema--so your system stays unified.

* * *

## 6) Guardrails (so the structure doesn't drift)

- Order lock: always keep the spine order identical; append atoms below links if you add many, or keep a standard atom order: method → findings → next → ledger.
- One "next" rule: enforce at most one actionable next.action. Use a backlog list for extras.
- Update stamp: whenever you meaningfully edit the body, bump state.updated (a QuickAdd macro or small Templater button helps).
- Validation dashboard: a note that lists problems to fix:

    - missing spine blocks

    - empty content

    - next.action set but state.status is done

    - state.updated older than N days

  

Example quick Dataview:
    
    
    TABLE file.link, choice(content.mode != "", "ok","missing content"), choice(length(sources.items) > 0, "ok","no sources")
    WHERE file.folder = this.folder

* * *

## 7) When to choose each approach (rule of thumb)

- If you hate empty sections → Hybrid, heavy on atoms.
- If you need strict consistency (team/shared vault) → Mega‑template or Hybrid with required atoms pre‑added by overlays.
- If you value speed above all → Bare‑bones + atoms, but keep the spine solid.
* * *

## 8) Migration plan (if you already have notes)

1. Add the spine (YAML + H2s) to all existing notes--batch insert if possible.

2. Map old fields to new names (sources vs inputs).

3. Add atoms only where they're clearly useful (projects, experiments).

4. Stand up the validation dashboard to catch gaps.

* * *

### Bottom line

  

Use the Hybrid: a spine in every note, atoms you can drop in instantly, and type overlays that compose those atoms--never fork the schema. It's universal, queryable, and light enough that you'll actually use it.

  

If you want, I can generate ready‑to‑paste templates/snippets for your exact plugin stack (Templater vs QuickAdd vs plain snippets).