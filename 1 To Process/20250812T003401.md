---
owner: Ben Jendyk
id: 7f7cb568-4fc0-4579-87dc-4d84601e542b
created: 2025-08-12T00:34:01+0200
modified: 2025-08-12T00:34:01+0200
tags: [access/public, language/en]
key-words: []
aliases: [Node & package manager]
title: Node & package manager
---

Awesome—Cursor is a great pick for “vibe coding” because it’s VS Code-compatible, has built-in AI chat, and works nicely with containerized dev on Silverblue.

Here’s a clean, founder-friendly setup you can do once and keep reusing.

⸻

0) Install Cursor on Silverblue
	•	Grab the AppImage from Cursor’s Linux downloads (works reliably across distros).
	•	Make it executable and integrate it:

chmod +x ~/Downloads/Cursor-*.AppImage
~/Downloads/Cursor-*.AppImage --appimage-extract
./squashfs-root/AppRun

(Optional: move it somewhere on PATH or create a desktop entry. If Cursor ships an RPM by the time you read this, rpm-ostree install <cursor.rpm> is also fine.)

⸻

1) Containerized dev (Silverblue-friendly)

Keep the OS clean; do everything in containers.

Enable Podman socket (for devcontainers):

systemctl --user enable --now podman.socket

Option A — Dev Containers (recommended):
Cursor understands VS Code’s Dev Containers.
	•	You’ll put a .devcontainer/devcontainer.json in each repo.
	•	Cursor will “Reopen in Container”, giving you a reproducible, isolated dev env per project.

Option B — Toolbox (lighter, no config):

toolbox create --image registry.fedoraproject.org/fedora-toolbox:40 dev
toolbox enter dev

Install your CLIs inside that toolbox. Use Podman for databases.

⸻

2) Core tools you’ll use (pick your stack, install inside the container/toolbox)

For a Next.js/TypeScript SaaS (fastest path to shipping)

# Node & package manager
corepack enable           # enables pnpm bundled with Node
# if Node isn’t present in the container image:
dnf install -y nodejs npm # (toolbox) or use a Node devcontainer image
npm i -g pnpm

# Useful CLIs
dnf install -y git gh     # GitHub CLI (toolbox) or apt/yum equivalent in container
npm i -g vercel

# Testing / automation
pnpm add -D @playwright/test
npx playwright install --with-deps

# Observability
pnpm add @sentry/nextjs
pnpm add posthog-js

# Validation
pnpm add zod

# UI
pnpm add -D tailwindcss postcss autoprefixer
pnpm add class-variance-authority tailwind-merge # optional niceties

# DB
# EITHER Prisma + hosted Postgres (Neon/Supabase)…
pnpm add prisma @prisma/client
# …or Supabase client SDK (if you want to rely on Supabase features):
pnpm add @supabase/supabase-js

# Payments (optional, common)
dnf install -y stripe-cli || brew install stripe/stripe-cli

For a Python/FastAPI backend (if you prefer scripts/APIs)

dnf install -y python3-pip python3-devel git
pip install --user uv        # modern Python package manager
pip install --user fastapi uvicorn[standard] pydantic-settings
pip install --user playwright pytest httpx
playwright install --with-deps
pip install --user sentry-sdk psycopg[binary]


⸻

3) Databases (local or managed)

Managed (fastest):
	•	Supabase: Postgres + auth + storage. Copy env vars into .env.
	•	Neon: serverless Postgres; pair with Prisma.

Local (Podman):

podman run -d --name pg \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_DB=app \
  -p 5432:5432 \
  postgres:16


⸻

4) Dev Container templates (drop-in)

Next.js devcontainer

Create .devcontainer/devcontainer.json:

{
  "name": "nextjs-app",
  "image": "mcr.microsoft.com/devcontainers/javascript-node:1-20-bullseye",
  "features": {
    "ghcr.io/devcontainers/features/git:1": {},
    "ghcr.io/devcontainers-contrib/features/pnpm:2": {},
    "ghcr.io/devcontainers/features/docker-outside-of-docker:1": {}
  },
  "postCreateCommand": "corepack enable && pnpm install",
  "customizations": {
    "vscode": {
      "extensions": [
        "esbenp.prettier-vscode",
        "dbaeumer.vscode-eslint",
        "bradlc.vscode-tailwindcss",
        "ms-playwright.playwright",
        "Prisma.prisma"
      ]
    }
  },
  "forwardPorts": [3000, 9229],
  "remoteUser": "node"
}

FastAPI devcontainer

{
  "name": "fastapi-app",
  "image": "mcr.microsoft.com/devcontainers/python:3.11",
  "features": {
    "ghcr.io/devcontainers/features/git:1": {},
    "ghcr.io/devcontainers/features/docker-outside-of-docker:1": {}
  },
  "postCreateCommand": "pip install -U uv && uv pip install fastapi uvicorn[standard] pydantic-settings playwright pytest httpx sentry-sdk psycopg[binary] && playwright install --with-deps",
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance",
        "ms-python.black-formatter",
        "ms-python.isort",
        "ms-playwright.playwright"
      ]
    }
  },
  "forwardPorts": [8000]
}

Open the folder in Cursor → “Reopen in Container”.

⸻

5) Cursor setup that helps you vibe-code

Extensions you’ll want (VS Code-compatible):
	•	ESLint, Prettier, Tailwind CSS IntelliSense
	•	Playwright Test
	•	Prisma (if using Prisma)
	•	GitHub Pull Requests & Issues (optional)
	•	Docker (if you plan to edit containers from the editor)

Cursor settings (File → Preferences → Settings → search “format”, “eslint”):

{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "eslint.validate": ["javascript", "javascriptreact", "typescript", "typescriptreact"],
  "files.eol": "\n",
  "typescript.tsserver.experimental.enableProjectDiagnostics": true,
  "terminal.integrated.defaultProfile.linux": "bash"
}

A couple of reusable Cursor prompts (save as snippets/notes):
	•	Spec → code scaffold:
“You are my TS/Next.js copilot. Build a page with [n] sections: [describe]. Use Tailwind, create a server action that [describe], add Zod validation, show optimistic UI, and wire it to Prisma model [name/fields]. Return complete files.”
	•	Read/extend:
“Read the file below. Briefly explain it, then add [feature] with minimal changes. Return the updated file only.”
	•	Debug:
“Given this error and code, show the smallest diff to fix it and why.”

⸻

6) Project bootstraps (copy/paste)

Next.js app (with basics)

pnpm create next-app@latest myapp --ts --eslint --app --src-dir --tailwind
cd myapp
pnpm add zod @sentry/nextjs
pnpm add -D @playwright/test
npx playwright install --with-deps

	•	Sentry: npx @sentry/wizard@latest -i nextjs (paste DSN)
	•	Smoke test: create tests/smoke.spec.ts:

import { test, expect } from '@playwright/test';
test('loads homepage', async ({ page }) => {
  await page.goto(process.env.BASE_URL ?? 'http://localhost:3000/');
  await expect(page).toHaveTitle(/myapp/i);
});

Run: pnpm exec playwright test

	•	Deploy: vercel (or connect repo in Vercel UI)

FastAPI app (super small)

mkdir fastapp && cd fastapp
printf "%s\n" \
"from fastapi import FastAPI\napp = FastAPI()\n@app.get('/health')\ndef health(): return {'ok': True}" > main.py
uv pip install fastapi uvicorn[standard]
uvicorn main:app --reload


⸻

7) Day-to-day commands you’ll actually use

# Dev (Next.js)
pnpm dev

# Run your smoke test
pnpm exec playwright test

# Start/stop local Postgres
podman start pg
podman stop pg

# Deploy (Vercel)
vercel


⸻

8) Minimal “quality floor” you should keep
	•	One Playwright smoke test on your #1 happy path.
	•	Zod (TS) or Pydantic (Python) on all external inputs.
	•	Sentry enabled in prod from day one.
	•	.env (never commit secrets) + a short README.md with “Run dev, test, deploy”.

⸻

If you tell me Next.js vs FastAPI and Supabase vs Neon/local, I’ll hand you a ready-to-commit starter repo (devcontainer + scripts + Sentry + a smoke test) tailored to your picks so you can start shipping the same day.