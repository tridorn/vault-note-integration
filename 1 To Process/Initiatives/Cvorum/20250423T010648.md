---
owner: Ben Jendyk
id: 825af03e-d890-49f7-8f2a-de27ebb543e3
created: 2025-04-23T01:06:48+0200
modified: 2025-05-16T18:43:26+0200
tags: [access/public, language/en, a/ip, pr/25/084, tf/quarter]
key-words: []
---

Below is a *deliverable‑ledger*: every artefact you must produce, why it exists, the moment of maximum leverage for producing it, the form it should take, and the recommended instrument for authoring. Build them in the listed order; each becomes an input for the next tier.

| # | Deliverable (Concrete Output) | Purpose (Strategic Function) | **When** to Produce & Why That Moment | Canonical Form | Recommended Tool / Medium |
|---|------------------------------|------------------------------|---------------------------------------|----------------|---------------------------|
| **1** | **Actor Capability Matrix** | Codifies each party’s powers, obligations, and forbidden actions → eradicates role ambiguity. | **Day 0 — before any flow design.** Roles constrain every subsequent artefact; iterating later multiplies rework cost. | 1‑page matrix (rows = actors, cols = Can Do / Must Do / Cannot Do / Trigger‑Events). | Spreadsheet (Excel / Google Sheets) or Notion table — trivial to diff & annotate. |
| **2** | **Actor Trigger Ledger** | Lists every event that compels each actor to act → enables event‑driven choreography. | Immediately after #1; same session. | Table appended to #1. | Same file as #1 for tight coupling; separate tab. |
| **3** | **Artifact Catalogue** | Exhaustive register of documents/data objects that travel the system. Establishes “what moves”. | **Pre‑flow, post‑actor.** Documents are the lifeblood; without them flows are fictional. | Bullet list with UID, short description, owner‑of‑record. | Markdown doc in repository (e.g., README_artifacts.md) for version control. |
| **4** | **Artifact State‑Machine Diagrams** | Gives each artifact a finite, auditable lifecycle → prevents data limbo. | Directly after #3; states depend only on artifact definition. | One diagram per artifact: states + allowed transitions. | Camunda Modeler (BPMN state‑task), or plain PlantUML Statecharts committed to Git. |
| **5** | **Zone Flow Maps (BPMN Swimlanes)** | Shows intra‑zone logic (Onboarding, Origination, …) without cross‑zone clutter → modular reasoning. | **Once #1‑#4 are stable.** Otherwise swimlanes mutate. | Six diagrams, one per zone. | Camunda Modeler or draw.io; export as PNG into Confluence page. |
| **6** | **Protocol Mesh Diagram (Choreography / Sequence)** | Depicts permissible message exchanges between actors across zones → clarifies concurrency & race conditions. | Immediately after each Zone Map drafts; cross‑reference them. | Unified sequence diagram that spans the full lifecycle. | PlantUML “@startuml sequence” in Git; renders automatically on push. |
| **7** | **Governance & Transition Table** | Tabular rules: *State → Event → Next State* plus *Authorized Actor*, *Timeout*, *Fallback*. Guarantees deterministic behaviour. | Parallel with #6; both reference the same transitions. | Wide, filterable table. | Airtable (for quick querying) or Excel with conditional formatting. |
| **8** | **Incentive–Compliance Matrix** | Maps each state/transition to regulatory requirement or incentive payout → embeds business case. | **After governance logic is frozen.** Incentives attach to controlled states. | Table: row = State/Transition, col = Reg‑Citation, Incentive‑Mechanism. | Notion DB or spreadsheet; export PDF for regulator conversations. |
| **9** | **Master System Architecture Deck** | Synthesises diagrams and tables into a narrative a banker or regulator can consume in 15 min. | Once #1‑#8 reach 80 % stability (pre‑pilot). | 15‑slide deck: problem → actors → flows → controls → upside. | PowerPoint / Google Slides; embed SVGs from previous steps. |
| **10** | **Implementation Backlog (User Stories / Tickets)** | Converts architecture into executable engineering units. | After deck approval by strategic stakeholders (bank/regulator buy‑in). | Epics & stories, each linked to artefacts and UML IDs. | Jira or Linear; auto‑link PlantUML commit hashes. |
| **11** | **Test Harness Specification** | Defines automated tests asserting state‑machine integrity and regulatory proofs. | Immediately after backlog creation; guards against scope erosion. | Gherkin (Given/When/Then) files tied to states & transitions. | Cucumber + GitHub Actions pipeline. |
| **12** | **Live Compliance Dashboard** | Real‑time view of dossier status, verification cycles, incentive triggers → operational cockpit. | MVP pilot stage — earliest point where live data flows. | Single‑page dashboard with KPIs and state heat‑map. | Grafana hooked to event store (Kafka topic) via PostgreSQL view. |

### Execution Notes & Rationale

1. **Lock Actors and Artifacts first** — they are ontological ground truth. Every change here cascades exponentially.
2. **Prefer text‑file formats under Git** (Markdown, PlantUML) for versioned artefacts; diagramming GUIs should export machine‑readable code.
3. **Swimlane → Sequence bifurcation** contains complexity: keep zone‑internal processes readable, push cross‑zone logic to the mesh.
4. **Governance rules in tables, not prose.** Audit teams consume CSVs, not paragraphs.
5. **Dashboards last.** Instrument only what the state‑machines prove is meaningful; avoid vanity metrics.

Adhere to this ledger and your design process becomes a disciplined pipeline of *artefact production*, not a swirl of meetings. Proceed.