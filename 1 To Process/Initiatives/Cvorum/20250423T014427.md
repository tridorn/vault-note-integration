---
owner: Ben Jendyk
id: 305ccd0f-093f-4421-880d-82281ea8b70d
created: 2025-04-23T01:44:27+0200
modified: 2025-05-16T18:43:26+0200
tags: [access/public, language/en, pr/25/084, tf/quarter]
key-words: []
---

You're not doing it wrong. You're doing what most first-time founders must: **constructing a conceptual scaffolding in real-time**, while parsing domain complexity with limited experiential heuristics. Your current structure—a set of top-level functional flows with nested sub-processes—is conceptually valid. However, it lacks *operational clarity* and *logic-anchoring mechanisms* that allow it to scale, evolve, or be stress-tested. You’re building a map, but right now it’s more of a topographical sketch than a navigable system.

Let’s assess your architecture on three levels: **structural merit**, **functional logic**, and **founder-leverage realism**.

---

### I. Structural Merit — Is the Flow Model Sound?

Your approach of defining top-level flows (Onboarding, Origination, Verification, etc.) is **semantically tidy**, but in its current linear framing, it likely fails to capture two critical realities:

1. **Concurrency & Feedback Loops**  
   In practice, flows are rarely sequential. Verification might inform onboarding retroactively. Reporting might trigger re-verification or require re-submission. Your mention of mesh-like behavior is an accurate insight—flows are better understood as **state transitions** between system actors, often cyclic or recursive.

2. **State vs. Action Confusion**  
   Each top-level flow you’ve named mixes “what needs to be done” (Submission) with “why it’s done” (Origination) or “what it triggers” (Decision). This suggests you’re combining **functional purposes** with **process stages**. Instead, **anchor your flows in state changes of the key asset: the loan file**.

---

### II. Functional Logic — How Do You Model Movement?

What you lack now is a **logic of transitions**—a precise understanding of what triggers state changes and which actor owns each change. Without that, you can't truly simulate or automate the flow. Consider this reframing:

- **Objects, Not Only Actors**  
  Define core objects (Loan File, Vendor Quote, Verification Report, Compliance Certificate, etc.) and map how these change form and status across flows.

- **Finite State Machines for Key Objects**  
  Each object should be modeled as a finite state machine. For example:

  - **Loan File States**: Draft → Verified → Submitted → Underwriting → Approved → Disbursed → Monitored → Closed
  - Triggers: Vendor input, verifier approval, SME signature, bank review, etc.

  This provides **executional determinism**—a clear view of what needs to happen for something to move from one state to the next.

- **Directed Graphs Instead of Linear Flows**  
  Visualize your system as a **directed acyclic graph** (or possibly a cyclic one, if recursion is needed), where nodes are states or documents, and edges are transitions triggered by actor inputs.

---

### III. Founder-Leverage Realism — Are You Building What You Need?

You are over-indexing on describing "what happens" and underbuilding the underlying **decision logic** and **operational primitives** that will actually be required to:

- **Automate decisions** (e.g., is the verification data sufficient?)
- **Assign responsibilities** (e.g., who owns the burden of proof?)
- **Resolve disputes** (e.g., what happens if verifier and vendor disagree?)
- **Maintain auditability** (especially with regulators in play)

You need to focus on:

- **Codified business rules**: What constitutes a “valid” loan origination? What’s an acceptable verification standard?
- **Permission layers**: Who can modify what data, when, and why?
- **Traceability**: Every transition should generate a loggable artifact.

This is less about visual design and more about *architectural spine*—build logic like a jurist, not a designer.

---

### Recommendations (Tactical and Strategic)

#### A. Build This Core Set of Artifacts:

1. **Actor-Action-Asset Table**  
   A table listing:
   - Actor (e.g., SME, Vendor, Platform)
   - Action (e.g., Submit Quote, Verify Data)
   - Asset Affected (e.g., Loan File, Vendor List)
   - Resulting State or Outcome

2. **Loan File State Machine**  
   Model the Loan File as your central object. Sketch its possible states and transitions as a diagram, then map each transition to the actor and condition that causes it.

3. **Directed Flow Graph**  
   Build a DAG (directed acyclic graph) of the process flow, using tools like Mermaid.js or Whimsical. Nodes = object states; Edges = transitions. Optional: annotate edge conditions.

#### B. Codify Conditional Logic Early

Don't wait to build product before defining "rules of progression". Codify what each actor needs to *provide* or *fulfill* at each stage. This will later become API logic and smart contracts if needed.

#### C. Treat Verification as a Service Layer, Not a Step

Don’t treat verification as a one-time process. It’s a **continuous service**—called whenever a truth-claim is made. Architect it like a modular plug-in that any step can trigger.

---

### Summary: Your Current Flow Is a Useful Draft, But Not a System

What you’ve created is a proto-framework. It gives you directional clarity. But without **state transitions**, **asset-based thinking**, and **modular logic units**, it will collapse under the weight of edge cases and scale.

You are not building a timeline. You’re building a **logic engine** for a regulated marketplace with multi-actor dependency chains. Model accordingly.

Would you like help drafting the state machine or visualizing the graph logic next?