---
owner: Ben Jendyk
id: dc7b60ba-c816-4f9c-b94d-b7a80e29b749
created: 2025-08-16T14:51:32+0200
modified: 2025-08-16T14:51:34+0200
tags: [access/public, language/en]
key-words: []
aliases: [Languages that actually matter]
title: Languages that actually matter
---

A tighter way to ask: "Which languages are essential for a Next.js + Supabase-style stack, is Supabase itself a language, and what is the most effective 'happy-path' stack to launch and test many subdomain services under one core site?"

  

# Languages that actually matter

- TypeScript: the primary language for UI, server actions, API routes, and infra scripts in a JS-centric stack. Reduces runtime bugs and improves refactors.
- SQL (PostgreSQL) + a bit of PL/pgSQL: schemas, migrations, constraints, row-level security, performance. You cannot outsource this to an ORM.
- HTML/CSS (Tailwind accelerates CSS, but you still need fundamentals).
- Bash + minimal YAML/JSON: CI, container scripts, infra pipelines.

Optional, high leverage later: Go or Python for heavier workers; both integrate cleanly with queues and cron.

  

Supabase is not a language. It's a managed Postgres platform with services (Auth, Storage, Realtime, Edge Functions) and SDKs (including JavaScript). You mainly write SQL and TypeScript against it.

  

# "Most powerful" happy-path stack for many services on subdomains

  

Goal: ship numerous smaller services on service.domain.com with minimal coordination, shared auth, unified payments, and low operational drag.

  

## Core choices

- Runtime and UI: Next.js (App Router) + TypeScript.
- Hosting: Vercel for the web tier (automatic previews, subdomain routing, edge caching).
- Data + auth + files: Supabase (Postgres, Auth with RLS, Storage). Use one project per environment; add a second project only if compliance or noisy neighbors demand isolation.
- Payments: Stripe (Checkout + Customer Portal first; avoid custom payment forms until necessary).
- Email + transactional comms: Resend.
- Analytics and session replay: PostHog.
- Error tracking: Sentry.
- DNS/edge: Cloudflare in front of Vercel for DNS and simple WAF; keep caching rules simple to avoid double-caching complexity.

  

## Repository and deployment topology

- Monorepo with pnpm + Turborepo.

    - apps/

        - web (core site at www.domain.com)

        - svc-{name} (each subservice at {name}.domain.com)

    - packages/

        - ui (shared components via shadcn/ui)

        - config (ESLint, TS, Tailwind presets)

        - lib (shared utilities: auth client, billing helpers)

        - db (Drizzle schema + migrations)
- Each app deploys independently to Vercel; map subdomains per app.
- Environment variables via Doppler or Infisical; never hand-roll .env distribution. Use environment groups for "shared across all services".

  

## Auth and session model across subdomains

- Supabase Auth with cookie domain set to .domain.com for SSO across sub-sites.
- Next middleware to guard routes; server actions validate sessions on every mutation.
- RLS on every table; service role key is server-only and never exposed to clients.

  

## Data access

- Drizzle ORM for type-safe SQL; raw SQL for hot paths.
- Reads in Server Components; mutations via Server Actions; cache with revalidateTag and explicit tag invalidation on write.
- For bursty serverless traffic, prefer Supabase RPC/REST over persistent pool connections.

  

## Payments pattern

- One Stripe account and one Product catalog; each subservice maps to a Product + Prices.
- Use Stripe Checkout to avoid PCI scope; webhooks handled in a single "billing" app or the core web app's route handler, then fan out to subservices via a queue.
- Customer Portal turned on from day one for refunds and plan changes.

  

## Realtime and background work

- Only add realtime where it moves metrics (collaboration, live counters, notifications). Supabase Realtime is fine.
- Background jobs: Supabase Edge Functions for light CRON and webhooks; graduate heavy jobs to a worker on Fly.io or Railway with a simple queue (Upstash Q or Redis).

  

## CI/CD and testing

- GitHub Actions with three lanes:

    1. Type checks + lint + unit tests (Vitest) on every push.

    2. E2E (Playwright) on preview URLs for changed apps.

    3. Database migrations dry-run on a disposable database, then apply on merge.

- Synthetic checks: cron pings + login flow test for each subdomain.
- Performance budgets: fail the PR if LCP or TTFB regress beyond tolerant thresholds.

  

## Observability and ops

- Sentry everywhere (server and client).
- PostHog product analytics; track funnel to paid and key retention events.
- Log aggregation: Vercel + Supabase logs are sufficient initially; add Datadog only when you actually need cross-source queries.
- Backups: rely on Supabase managed backups plus weekly logical dumps to a separate object bucket.

  

## Security and tenancy

- Default deny RLS; create policies per role explicitly.
- DB constraints over app logic for invariants that must never break.
- API rate limiting at the Vercel edge; IP + user-based counters in DB for abusive patterns.

  

## Concrete "happy-path" scaffolding

- create-t3-turbo or a minimal Turborepo template.
- Packages installed in all apps: next, typescript, @supabase/supabase-js, @supabase/auth-helpers-nextjs, drizzle-orm, drizzle-kit, zod, react-hook-form, @tanstack/react-query, sentry/nextjs, posthog-js, tailwindcss, shadcn/ui.
- One shared db package provides:

    - schema.ts (Drizzle models)

    - migrations/ (SQL)

    - helpers for creating server-side Supabase clients
- A generator script pnpm gen:service mysvc that:

    - clones apps/svc-template into apps/svc-mysvc

    - wires domain to Vercel via CLI

    - sets ENV group, Stripe Price IDs, and Sentry DSN

    - deploys a preview and posts URL back to the PR

  

## Core site vs experiments

- Core site (www.domain.com): Next.js with ISR for marketing pages, a "/account" area shared across offerings, billing portal link, and a "launcher" that routes users into subservices based on entitlements.
- Experiments (subdomains): identical baseline app with:

    - feature flags table in Postgres (or Unleash if you need targeting)

    - one PostHog project tag per service

    - isolated Stripe products and usage meters if needed

    - kill-switch flag that 301s back to the core site

  

# Decision rules to keep velocity

- If a service can be a page under the core site without auth boundaries, keep it inside web; avoid a new app.
- New subdomain only when it needs materially different runtime, experiment isolation, or has separate billing.
- No GraphQL until you have at least two independent clients or third-party API consumers. Server Actions + thin REST are faster and cheaper.
- No Kubernetes. Vercel + managed DB is enough until you hit real scale or compliance constraints.
- Write SQL migrations before code. Schema drift is the fastest way to stall the team.

  

# Minimal skill set to be effective quickly

- TypeScript fluency with Next.js server/client boundaries.
- Practical SQL: table design, indexes, joins, RLS policies, transactions.
- CI basics with GitHub Actions, and comfort with reading logs and traces.
- Stripe primitives: products, prices, Checkout, webhooks.
- Tailwind for fast UI without design overhead.

  

Bottom line: learn TypeScript and SQL; treat Supabase as your managed Postgres + auth backbone, not a language. Use Next.js on Vercel for the web edge, Stripe for money, and a monorepo to stamp out subdomain services quickly. Keep everything default-deny on the data side, test end-to-end on preview URLs, and push new services only when a clear boundary or billing case justifies the extra surface.