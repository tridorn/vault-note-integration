---
owner: Ben Jendyk
id: 9ef1e273-7f72-40c3-9e0f-1290aa633b68
created: 2025-08-12T00:29:04+0200
modified: 2025-08-12T00:29:04+0200
tags: [access/public, language/en]
key-words: []
---

Correction: You should have written: “Assuming an SME designed around digital infrastructure, systems-thinking, and minimal reliance on consumer-oriented software—what would it look like to scale that from 1 to 10,000 employees using NixOS and infrastructure-native tooling?”

⸻

Strategic Context

You’re describing a company with a high-discipline, infrastructure-native, code-defined operational model:
	•	Minimal reliance on ad hoc tooling or legacy software conventions
	•	Everything under version control, automated, and declaratively managed
	•	Internal workflows treated like systems, not exceptions
	•	Employees are treated as nodes within a coherent digital topology

This isn’t a normal SME. It’s infrastructure-native by design.

⸻

What Such a Company Looks Like

Cultural Assumptions
	•	Every employee is expected to interface with infrastructure, directly or indirectly
	•	All systems and user environments are declared, versioned, tested, deployed
	•	No unmanaged endpoints; no special cases
	•	“I need an app” becomes “fork the config, submit a merge request”

Implication: Even non-engineering roles operate within engineered environments.

⸻

1. Workstation Strategy: NixOS

Layer	Characteristics
Base OS	NixOS with role-specific modules (e.g. sales.nix, dev.nix)
Provisioning	PXE boot, nixos-install, or nixos-anywhere
State Management	Flake-based deployments via GitOps
Rollback Support	Native with nixos-rebuild generations
Fleet Updates	CI-triggered rebuilds + deployment tooling (e.g. Morph)

All workstations are built from source + config, deterministically.
Rollbackable, auditable, uniform.

⸻

2. Authentication and Identity
	•	LDAP / SSSD / Keycloak integration declared in Nix
	•	All employees are issued SSH keys, optionally YubiKeys
	•	No passwords stored on endpoints
	•	NixOS handles PAM config and authentication chaining

⸻

3. Application Layer

App Category	Approach
Comms (Slack, etc.)	Web + Flatpak + internal bridging layers
Office tooling	Markdown + Git + Pandoc + internal converters
Note-taking / Docs	Git-based markdown vaults (Obsidian, etc.)
Project mgmt	Git-based workflows (e.g. issue-tracking in GitLab repos)
Video conferencing	Minimalist (Jitsi on browser) or isolated Flatpaks

There is no reliance on commercial binaries outside containers or Flatpaks.
Internal abstraction layers are built if necessary to bridge gaps.

⸻

4. File Management and Storage
	•	All local files are ephemeral or mounted via NFS/WebDAV/S3
	•	User vaults = git repos
	•	Shared drives = versioned S3 buckets with lifecycle policies
	•	File access via CLI or lightweight GUI frontends

No ad-hoc document management, no local hoarding.

⸻

5. CI/CD: Personal and Org-Wide
	•	Every machine role has its own testable config in CI
	•	Users have .devShells for language- or role-specific contexts
	•	Onboarding = assign Git repo access → laptop builds from assigned config
	•	Updates pushed to branches → merged → mass-rebuilt + deployed

This is infrastructure as fleet code, not just infra as code.

⸻

6. Support and Operations
	•	No “help desk” in the traditional sense
	•	All support is configuration-based: you don’t fix, you patch and redeploy
	•	Breakage = open a PR, run CI, roll out
	•	Documentation = living, versioned markdown vaults, not wikis

⸻

7. Data Integrity and Recovery
	•	Backups are deterministic and distributed (e.g. Restic + S3 + version control)
	•	Rebuilds are fast, clean, and source-of-truth aligned
	•	User config = Git repo → laptop loss = clone and rehydrate

⸻

8. Scaling Org Complexity

Growth Stage	Structural Move
1–10	Manual flake edits, shared secrets, raw config updates
10–100	GitOps branching, per-role flakes, shared CI
100–1000	Secrets management (Vault), centralised provisioning repo
1000–10,000	NixOps variant, internal platform team, full SDLC on config

This scales by treating platform as product. You grow by productising the internal digital substrate, not reacting ad hoc.

⸻

Why This Works

Because you:
	•	Reduce the number of stateful moving parts
	•	Automate almost all human error out of the system
	•	Accept that everything is code—even desktops, even HR workflows
	•	Minimise surface area for unexpected behavior

You’re not building an organisation around tools.
You’re building an organisation around controlled execution environments.

⸻

Risks and Counterforces

Constraint	Mitigation Path
Talent scarcity (Nix engineers)	Grow them internally or limit surface to modules
App compatibility gaps	Containerise or enforce alternatives
UX friction for non-technical staff	Limit freedom, script expected behaviors
Internal resistance to abstraction	Cultural: document, automate, remove variance

This model requires hard governance, not just good tools.

⸻

Bottom Line

Yes, an SME scaling to 10,000 could adopt NixOS if it commits to full infrastructure discipline across the org.
You’re not just deploying a distro. You’re constructing a closed, versioned ecosystem.

If you’re willing to treat every employee’s interaction as part of a structured, testable, and reproducible system,
NixOS becomes not just viable—but strategically superior.