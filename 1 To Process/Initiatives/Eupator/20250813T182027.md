---
owner: Ben Jendyk
id: bb835e3c-829e-4572-b3ff-a48c2e0133df
created: 2025-08-13T18:20:27+0200
modified: 2025-08-13T18:20:29+0200
tags: [access/public, language/en]
key-words: []
---

You should have phrased this as: "Describe the step-by-step wedge strategy for a single founder to establish a provider-independent, standards-based company from zero, scaling it into a full organisation while maintaining the architectural discipline."

* * *

## 1. Starting conditions

- One founder.
- No code, no infra, no employees yet.
- The goal: design the rails first, so everything from the first line of code to the first hire runs on the same substrate.

  

The strategy is to build the rails before the train -- minimal viable rails, then immediately use them for your own work, so they evolve with real usage.
* * *

## 2. First wedge: the minimum viable rails

  

Objective: Create the simplest, working instance of the "canonical asset system" for yourself.

  

### Step 1 -- Pick standards, not vendors
- Git: Self-hosted (Gitea) or GitHub with the ability to export and mirror.
- Object storage: S3 API (could be MinIO on your laptop to start).
- Database: Postgres (single node initially).
- Auth: OIDC provider (Keycloak locally or small hosted equivalent).
- Automation runner: Local CI (GitHub Actions, Drone CI, or equivalent) that reads declarative YAML from Git.

  

At this stage, you might run it all on a single small cloud VM or on your laptop using Docker. The point: every component speaks an open protocol.

* * *

### Step 2 -- Establish the first repos

1. infra-bootstrap

    - Terraform/Ansible/Docker Compose to spin up your Git, object store, DB, and IdP.

    - This is the root of your infra. All infra changes will be PRs here.

2. docs-policies

    - README with the "rails" principles.

    - SECURITY.md, LICENSE, CODEOWNERS (you).

3. infra-identity

    - RBAC roles in YAML.

    - Provisioning scripts to apply roles to the IdP.

4. ops-scripts

    - Your first helper scripts for backups, object uploads, etc.

  

You've now made yourself the first user of the rails.

* * *

### Step 3 -- Wire the control plane
- Build a very thin API gateway (can be a Flask/FastAPI app or even shell scripts at first) exposing:
    
    
    /git/... 
    /storage/... 
    /db/... 
    /identity/...

-   
- Everything you do (commit, upload, query) goes through this API, even if it's just wrapping the real tools locally.

  

Purpose: force yourself to use the same abstraction employees will use later.

* * *

### Step 4 -- Event backbone (early)
- Start with a simple message broker (NATS or even Redis Pub/Sub for first month).
- Define JSON envelope schema for events.
- Log each API action as an event into a file or Postgres table.
* * *

## 3. First loop: make yourself operational

  

Run your own "company" like it's already multi-person:

1. Create an org structure file in org-structure -- even if it's just you.

2. Track your own tasks as issues in ops-scripts or biz-foundation.

3. Make decisions in docs-decisions as Markdown, commit them via PR.

4. Use object storage for any binary: invoices, mockups, data dumps.

5. Build your first automation: on org-structure change, print a log -- proof onboarding works.

  

You are now your own HR, Ops, and Engineering, on the rails.

* * *

## 4. Second wedge: make it useful to someone else

  

### Step 5 -- Offer value on top of your rails

  

Pick a domain where your first "product" fits, but design it as a service repo (svc-*) that:

- Is committed to Git.
- Builds via CI.
- Ships artifacts to object storage.
- Deploys via infra repo PR.

  

Even if this "product" is internal (e.g., analytics dashboard), it exercises all rails.

* * *

### Step 6 -- First hire or collaborator
- Before they touch anything, you:

    1. Add them to org-structure with role(s).

    2. Merge PR â†’ automation provisions IdP account, Git access, object store creds.

    3. Send onboarding checklist (in Git).

- Their first task is a small PR to ops-scripts or docs-policies -- tests the full workflow.
* * *

## 5. Scaling wedge: formalising governance early

  

By the time you're 2--3 people:

1. Enforce branch protection and CODEOWNERS.

2. Require all changes to go through PRs and the HTTP API.

3. Turn on event subscriptions -- even if they just log to a file, so history is complete.

4. Introduce the first service-level SLAs (PR review times, incident response).

* * *

## 6. Cultural embedding

  

From day one:

- All communication in chat gets formalised in Git within 24h.
- No private admin actions -- everything goes through the API/PR/event model.
- Everyone is both a user and a maintainer of the rails; if a rule is painful, they change it in docs-policies via PR.
* * *

## 7. Long-term expansion path

- Phase 1 (0--3 people): One VM, everything local, still through control plane.
- Phase 2 (3--10 people): Move Git, object store, and DB to managed or replicated instances; add CI runners; keep same APIs.
- Phase 3 (10--50 people): Introduce separate staging/prod; split repos by domain; enforce metrics collection.
- Phase 4 (50+ people): Roles expand, audit automation, DR drills, quarterly rails report.
* * *

## 8. Why this wedge works

- You don't build abstract "governance" in a vacuum -- you are the first governed entity.
- The control plane and event backbone are small at first, but you never break the model to "move faster."
- Hiring is immediately bounded by rails, so culture debt is minimal.
- From day one, migration between vendors is a config change, not a rewrite.
* * *

If you want, I can next give you the literal week-by-week build plan for the first 12 weeks -- showing exactly what repos, scripts, and automation you'd create and in what order so that by the end of 3 months you have both a working product and a working company operating system. That would make it operationally executable for a single founder.