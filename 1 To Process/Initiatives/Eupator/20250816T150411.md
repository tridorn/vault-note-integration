---
owner: Ben Jendyk
id: f861b3d1-863f-45ac-b86e-88f223a38117
created: 2025-08-16T15:04:11+0200
modified: 2025-08-16T15:04:12+0200
tags: [access/public, language/en]
key-words: []
aliases: [Opinionated stack (optimized for the happy path)]
title: Opinionated stack (optimized for the happy path)
---

A tighter way to ask: "Specify a minimal-friction stack to spin up many paid micro-services on subdomains of one core site, define ops for deploy/test/iterate, and outline the graduation plan when a service earns its own domain."

  

# Opinionated stack (optimized for the happy path)

  

## Domains, hosting, and networking

- DNS and TLS: Cloudflare. Use a wildcard *.domain.com proxied record. One click SSL, easy redirects, low ceremony.
- App hosting: Vercel. Native subdomain previews, instant rollbacks, edge middleware, environment management.
- Storage/auth/DB: Supabase (Postgres, Auth, Storage, Realtime). RLS by default. One primary project to start.

  

## Codebase shape

- Monorepo: Turborepo + pnpm.
- Framework: Next.js (App Router) + TypeScript.
- UI: Tailwind CSS + shadcn/ui. One shared @ui package.
- Shared libs: @config (env), @utils (logging, telemetry), @auth (Supabase helpers), @payments (Stripe helpers).
- Each service is a Next app in apps/{service} and deploys to {service}.domain.com.

  

Example layout:
    
    
    /apps
      /core         -> domain.com
      /notes        -> notes.domain.com
      /images       -> images.domain.com
      /xyz          -> xyz.domain.com
    /packages
      /ui
      /auth
      /payments
      /config
      /utils

## Data model and isolation

- Start: one Supabase project, one Postgres database.
- Isolation: one schema per service (core, notes, images, …). Name tables svc_entity.
- Access control: Postgres roles per service; Supabase RLS per table. No cross-schema reads from clients.
- Promote later: service gets its own Supabase project when needed; migrate schema via SQL dump + data copy.

  

## API surface

- Server actions (Next) for mutations.
- Reads in Server Components via Drizzle ORM (typed SQL) or Supabase RPC. Cache with revalidateTag.
- Zero public API at first. When you need one, add thin REST route handlers. Avoid GraphQL until you have multiple heterogeneous clients.

  

## Auth, plans, and payments

- Auth: Supabase Auth with email/password + OAuth. Session via HTTP-only cookies, validated server-side.
- Payments: Stripe Checkout + Billing Portal (no custom card forms). One product with metered or tiered prices per service.
- Entitlements: simple subscriptions table keyed by user_id, service_key, plan, status, expires_at. Read-only in UI, source of truth is Stripe webhooks.

  

## Observability and ops

- Errors: Sentry.
- Product analytics: PostHog (self-host later if needed).
- Logs: Vercel + Supabase logs; forward to a single store (Logtail or Datadog) when volume grows.
- Uptime: health endpoint per service and external ping.
- Feature flags: a Postgres table + cached read; add Unleash only if targeting rules get complex.

  

## CI/CD

- GitHub Actions:

    - Lint/typecheck/test on PR.

    - Preview deploy to Vercel per PR.

    - Tag-based prod deploys. One workflow fans out to affected services using Turborepo caching.
- DB migrations: Drizzle Kit. One migration folder per service schema. Run migrations on deploy via a single action.

  

## Edge and experimentation

- Routing: Vercel wildcard routing. Each service bound to {service}.domain.com.
- A/B and traffic splitting: Vercel Edge Middleware or Cloudflare Rules. Keep it cookie- or header-based; avoid random splits for logged-in flows.
- Realtime or background jobs: Supabase Edge Functions for light tasks. For heavier work or webhooks fan-out, add a single worker on Fly.io or Railway with a queue (Upstash Q). Don't add Kafka.

  

# Concrete "happy path" workflow

  

## 0) One-time platform setup

1. Point domain to Cloudflare. Create A/CNAME wildcard *.domain.com proxied.

2. Connect GitHub to Vercel; create a Vercel project for /apps/core. Enable preview deploys.

3. Create Supabase project. Configure Auth providers. Create roles: core_role, notes_role, etc.

4. Seed DB with schemas core, notes, … and baseline RLS policies. Enable backups.

5. Create Stripe products/prices for common plans. Webhook receiver in /apps/core/api/stripe/webhook.

  

## 1) Ship a new service in hours

1. Scaffold: pnpm dlx create-next-app apps/ideas, copy app/_template from a starter.

2. Create schema.sql via Drizzle for ideas schema. Add minimal items, subscriptions tables. Write allow-list RLS.

3. Implement views with Server Components; mutations via server actions. Use shared @auth and @payments.

4. Add a "Buy" CTA using Stripe Checkout. On webhook, upsert entitlement row.

5. Add project in Vercel pointing to apps/ideas. Assign ideas.domain.com. Set env vars from a shared .env.vault.

6. Merge to main. Preview goes live automatically; promote with a tag.

  

## 2) Validate with minimal ceremony

- Metrics to gate: activation rate, day-1 retention, revenue per user. Instrument from day one.
- Price tests use Stripe multiple prices; choose with a query param or flag.
- Rollbacks are Vercel instant. Use them; don't hotfix under pressure.

  

## 3) Operate many services without chaos

- Weekly housekeeping script: list services, check SLOs, stale previews, unpaid entitlements.
- Shared release cadence: only tag deploys on Tuesdays and Thursdays; previews any time.
- Cost guardrails: block enabling Realtime unless justified; S3-like storage limits per service; alert on egress spikes.

  

# Graduation path to its own domain

  

Trigger: consistent revenue, clear ICP, support burden warrants isolation.

  

## Step-by-step cutover

1. Fork infra boundaries

    - Create new Supabase project in the target region. Provision schema with Drizzle. Copy only relevant data (subscribers, active entities). Backfill via one-time dump + idempotent import.

    - New Vercel project for the service app. Bind to newbrand.com. Keep service.domain.com as a secondary domain for now.

2. Dual-write window

    - For 24--72 hours, mirror writes from old to new via a worker or webhook relay. Reads stay on old.

    - Freeze non-critical features during the window.

3. DNS and auth cutover

    - Move primary auth domain to the new host. If staying on Supabase Auth, rotate keys; export users if changing projects. Maintain session cookie names to avoid forced logouts where possible.

    - Swap UI endpoints to the new origin. Start serving service.domain.com from the new Vercel project; keep old responding with 302 to /login?from=legacy for stale sessions.

4. Billing separation

    - Create a new Stripe account only if finance requires it. Otherwise, keep one Stripe account, new Product IDs, and isolate by service_key.

    - Migrate customers: either leave as-is (fastest) or move to new products and map via the Billing Portal over a month. Do not mass-cancel.

5. Redirects and SEO

    - 301 from service.domain.com/* to newbrand.com/*. Preserve slugs. Submit sitemaps.

    - Keep the subdomain live for 90 days with redirects.

6. Data archival

    - Snapshot old schema; keep read-only for 6 months. Drop cross-schema privileges.

7. SLOs and monitoring

    - Define explicit p95 targets and error budgets for the now-independent service. Separate on-call and alerts.

  

# What the core site does

- Marketing hub at domain.com: landing, directory of services, shared auth entry, pricing overview, docs.
- Central billing portal link. One support desk entry point.
- Directory registry table maps {service} -> display name -> status -> Vercel project -> schema -> price plan.
- Edge middleware routes /{service} to https://{service}.domain.com for simple deep links.

  

# Tooling decisions you should not bikeshed

- Next.js + TypeScript everywhere. No separate API layer until necessary.
- Drizzle for migrations and typed queries. No heavy ORMs.
- Stripe Checkout and Billing Portal. No custom PCI surface.
- Cloudflare for DNS/SSL and coarse routing. Vercel for apps. Supabase for DB/auth/storage. PostHog + Sentry for visibility.

  

# Risks and countermeasures

- Connection limits on serverless Postgres: prefer HTTP RPC for bursty loads; pool for steady traffic. Budget N+1 with EXPLAIN before launch.
- RLS mistakes: write tests for policies. Disallow auth.uid() fallbacks that over-grant.
- Entitlement drift: all access checks server-side; never trust client flags. Re-verify on each request via cached entitlement read.
- Cost spikes from assets: throttle uploads, resize at ingress, set aggressive cache headers.

  

# Bottom line

  

One monorepo, one platform trio (Vercel + Supabase + Stripe), one DNS with wildcard, and strict schema isolation per service. This gives near-zero setup time per experiment, clean payments, and controlled graduation to independent domains without re-platforming.