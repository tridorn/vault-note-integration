---
owner: Ben Jendyk
id: e71985a8-60e5-45b7-86b1-8f0d4c5aaf7b
created: 2025-08-16T14:46:28+0200
modified: 2025-08-16T14:46:33+0200
tags: [access/public, language/en]
key-words: []
aliases: [What GraphQL is and where it sits]
title: What GraphQL is and where it sits
---

A tighter way to ask: "Define GraphQL, position it in a modern stack, compare it with REST, tRPC, and gRPC, and recommend the most effective choice for a typical web product."

  

# What GraphQL is and where it sits

  

GraphQL is a typed query language and runtime that exposes a single composable schema over your domain. It sits in the API layer between clients and your services or database. Transport is usually HTTP. Clients send declarative queries and mutations against the schema; the server resolves fields by calling downstream services or the database.

  

# The other options

1. REST over HTTP

Resource-oriented endpoints returning JSON. Simple, cacheable, CDN-friendly, ubiquitous tooling. Versioning and over/under-fetching are the usual frictions.

2. tRPC over HTTP

TypeScript RPC that infers types end to end in a mono-repo. Minimal ceremony, strong DX, no schema language. Tight coupling to TypeScript and your repo boundaries.

3. gRPC over HTTP/2

Binary Protobuf RPC with streaming. Strong contracts, speed, and multiplexing. Best for service-to-service and native clients. Browser usage needs a gateway.

4. Server actions and route handlers (Next.js)

Direct server functions invoked over HTTP with framework conventions. Excellent for a single web client. Not a public API by default. Low overhead.

5. Webhooks, SSE, WebSockets

Event delivery and realtime. These complement the above, not replace them. GraphQL has Subscriptions, REST often pairs with SSE or sockets.

6. Direct DB APIs (PostgREST, Supabase REST/RPC)

Autogenerated REST from SQL. Great for CRUD and internal tools. Policy management becomes critical.

  

# Strengths and trade-offs

  

GraphQL strengths

- Single endpoint with flexible querying for multiple clients.
- Strong schema and introspection enable tooling, codegen, and docs.
- Federation composes many services behind one graph.

  

GraphQL costs

- Resolver layer adds latency and complexity.
- Caching is harder at the edge. You often need persisted queries or a router.
- Authorization is field-level and policy heavy. Missteps are risky.
- Operational footprint: schema governance, breaking change control, N+1 pitfalls.

  

REST strengths

- Trivial to cache and scale at CDNs.
- Easy to observe and secure.
- Lower cognitive load, faster for straightforward domains.

  

REST costs

- Over/under-fetching unless endpoints are curated.
- Versioning discipline required.

  

tRPC strengths

- Fastest iteration for a TypeScript full-stack team.
- Types flow without codegen.

  

tRPC costs

- Not ideal for third-party consumers or polyglot teams.
- Harder to decouple when you split repos or languages.

  

gRPC strengths

- Efficient, strongly typed, streaming.
- Excellent for internal microservices.

  

gRPC costs

- Browser friction without a REST gateway.
- Tooling less familiar to front-end teams.

  

# What is "most powerful"

  

Define power as option value plus execution speed minus operational drag.

- Single product with one web client, one team, TypeScript: tRPC or thin REST plus server actions is most powerful. You ship faster with fewer moving parts.
- Multiple heterogeneous clients, public API ambitions, or many backend services: GraphQL wins. The schema becomes your product surface and lets clients compose without new endpoints.
- High-throughput internal microservices: gRPC wins. Use a REST or GraphQL edge for browsers.

  

# Concrete recommendations

  

Default for a SaaS or content app today

- Next.js App Router with server actions for mutations.
- Reads via server components calling a thin REST layer or direct RPC to your backend.
- Client caching with TanStack Query.
- If you use Supabase, start with its REST/RPC and add a minimal Next route layer for policy and caching.

Rationale: minimal API surface, easy caching, excellent performance, low ops.

  

When to adopt GraphQL

- You have at least two materially different clients, or you intend to offer a public API.
- Your domain is graph-shaped with many joins per screen where bespoke REST explodes.
- You can staff schema ownership, performance budgeting, and caching strategy.

Stack: Apollo Server or Helix, codegen, schema checks in CI, persisted queries, and either a router or CDN rules. Use Subscriptions only where realtime is essential.

  

When to avoid GraphQL

- Early product, one client, thin team. The overhead does not pay back.
- Heavy edge caching needs for public pages. REST is simpler and cheaper to cache.

  

Service-to-service pattern

- gRPC between services for efficiency and contracts.
- REST or GraphQL at the edge depending on the client mix.
- Webhooks for outbound notifications. SSE or sockets for realtime UX.

  

# Bottom line

  

GraphQL is an API style that sits at the contract layer, not a transport and not a database. Use it when client diversity and schema composition justify the machinery. Otherwise, ship with server actions plus a thin REST or tRPC slice. That is the rational power play for most teams starting now.