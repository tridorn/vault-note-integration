---
owner: Ben Jendyk
id: 2858173a-5be9-4f66-87ea-0de39b291d59
created: 2025-06-15T17:34:18+0200
modified: 2025-07-08T06:07:48+0200
tags: [access/public, language/en, pr/25/116, tf/quarter]
key-words: []
---

Your question should have been framed as: _"Identify the minimum-viable technology stack that can enforce the structural doctrine (artefact types, branch-per-Mission, immutable logs) without spawning tooling sprawl. Compare the real options and state a strategic recommendation."_

* * *

## Implementation Criteria _(what the stack **must** guarantee)_

1. **Native version control** for Markdown/YAML/CSV artefacts.

2. **Branching & Pull-Request workflow** (Mission branch → Project main).

3. **Automatable compliance checks** (naming, expiry, interface contracts).

4. **Immutable audit trail** (Decision-Ledger mirror).

5. **Role-based access control** (Council vs. Cell).

6. **Low-friction authoring UI** for non-technical staff.

7. **Binary support** for slide decks, design files, video proofs.

8. **API surface** for bots, dashboards, and analytics.
* * *

## Option Scan

| Stack | Strength | Fatal Weakness | 
| ---- | ---- | ----  |
| **Google Workspace / Drive** | Ubiquitous, low onboarding friction, native comments | No real branching; weak audit trail; scripts brittle | 
| **Microsoft 365 + SharePoint** | Enterprise IAM integration, decent version history | SharePoint merges cumbersome; poor Git-like flow | 
| **Notion or Coda** | Friendly UI, rich linking, light API | No branch semantics; diffing & rollback fragile | 
| **Pure GitHub/GitLab** | First-class branching, CI, audit, API | Steep learning curve for non-engineers; weak WYSIWYG | 
| **Confluence + Bitbucket** | Wiki front-end + Git back-end; unified permission model | Licensing cost; UX fragmentation; still Git for edits | 
| **Custom (proprietary micro-service)** | Perfect fit | High cap-ex; vendor lock-in; long lead time | 
* * *

## Rational Recommendation -- **Hybrid "Git-Core + Headless UI"**

| Layer | Tool | Rationale | 
| ---- | ---- | ----  |
| **Core Repository** | **GitLab Self-Managed** (or GitHub Enterprise) | Branch-per-Mission, Merge Requests, protected branches, Git LFS for binaries, granular RBAC. | 
| **Compliance Bot** | **GitLab CI / GitHub Actions** + custom linter scripts | Enforce artefact schema, expiry hooks, Decision-Ledger mirroring. | 
| **Headless Wiki Front-End** | **Docusaurus** (auto-build from repo) _or_**Confluence read-only mirror** | Non-technical staff view Markdown as rendered pages; edits still occur via Merge Requests. | 
| **Binary Object Store** | **AWS S3** (versioned) behind Git LFS pointer files | Keeps repo light; maintains single SHA history. | 
| **Intel Pipeline** | **BigQuery → Metabase dashboards** | IH pushes SignalBrief CSVs; auto-generates briefing decks. | 
| **ChatOps** | **Slack** with PR / CI notifications + `/blocker` shortcut | FO escalations and cadence alerts land where people live. | 

_Why not Notion?_ -- cannot guarantee branch integrity or immutable logs; good for commentary but not for canonical artefacts.  
_Why not Drive?_ -- merging Markdown edits in Google Docs is a governance nightmare; violates "typed interface" doctrine.
* * *

## Minimal Working Model (MWM)

1. **Template Repo** -- `company-template-project`  
_Pre-populated folders:_ `MasterContent.md`, `MetricMap.json`, empty `InterfaceContracts/`, etc.  
`git init-project.sh` scaffolds a PW in < 30 s.

2. **Branch Workflow**  
`main` = Project-Workspace (PW).  
`m-<code>` branches = Mission-Packs (MP).  
Merge Request labeled `FO-Ready`; CI runs:

    - lint for artefact presence & naming

    - expiry-hook for Metrics

    - Decision-Ledger append.

3. **CI Gate Rules**

    - Fail if `MasterContent.md` timestamp > Sprint end.

    - Fail if any `/InterfaceContracts/*.yaml` missing signature fields.

    - Warn if `RiskSheet.csv` unchanged ≥ 3 Pulses.

4. **Wiki Build**  
Every merge to `main` triggers Docusaurus build → static site on internal URL.  
Non-tech staff read, comment via PR discussions--not via live edits.

5. **Audit & Analytics**  
Nightly job pulls Decision-Ledger into a warehouse; dashboards alert SO if veto cycles exceed SLA.

* * *

## Transition Roadmap

| Phase | Duration | Tasks | Risk | 
| ---- | ---- | ---- | ----  |
| **Pilot** | 2 Missions | Seed template repo, run CI bot, gather FO feedback | Onboarding pain | 
| **Expansion** | Next 3 Projects | Migrate existing docs via scripted import; train Program Directors | Merge conflicts | 
| **Hard Cut-Over** | Quarter start | Block new work unless created via `git init-project.sh` | Shadow IT attempts | 
| **Optimise** | Continuous | UX tweaks, linter hardening, dashboard refinement | Bot false-positives | 
* * *

### Net Result

- Single canonical repo per Project -- zero fragmentation.
- Mission autonomy via branch isolation -- zero cross-team collisions.
- Immutable audit & cheap automation without proprietary lock-in.
- Non-engineers still consume content in a friendly rendered form.

Anything lighter fails the branch/audit requirement; anything heavier erodes speed. This hybrid stack is the minimal implementation that satisfies the doctrine.