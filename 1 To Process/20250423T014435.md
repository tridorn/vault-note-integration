---
owner: Ben Jendyk
id: 7ac12b91-63a8-44b7-b4f1-dbd3dc8ed9bc
created: 2025-04-23T01:44:35+0200
modified: 2025-05-16T18:43:26+0200
tags: [access/public, language/en, pr/25/084, tf/quarter]
key-words: []
---

Certainly. In the context of a startup building a transactional, multi-party platform—especially one operating in a regulated domain like green credit—**terminological clarity isn't academic, it's architectural**. You’re engineering a coordination system. That means you need to distinguish between four fundamental concepts: **actors**, **actions**, **objects**, and **states**. Let’s define them sharply and show how they relate to each other in system design.

---

### I. **Actor** – _Who Performs the Action_

An **actor** is an autonomous agent capable of initiating or responding to actions within your system. Think of them as **decision-makers or processors**. Actors can be human (e.g. SME owner) or institutional (e.g. bank underwriting engine).

#### Examples:
- SME
- Vendor
- Platform (your system, acting as orchestrator)
- External Verifier
- Bank
- Regulator

In modern system design, each actor **possesses permissions** and **is constrained by roles**, often implemented through access control logic.

---

### II. **Action** – _What Is Being Done_

An **action** is a discrete operation **performed by an actor** on or with respect to a system object. In formal systems, an action is often a function call, a form submission, or a transaction. It is **intentional and leaves a trace**.

#### Examples:
- Submit Application
- Approve Vendor
- Generate Verification Report
- Upload Compliance Document
- Trigger Underwriting Review

Actions are how **state changes** are initiated. In systems language: _events trigger transitions_.

---

### III. **Object** – _What Is Acted Upon_

An **object** is a persistent, mutable entity that holds structured data and represents a **thing of value** in your ecosystem. Think of objects as **the payloads** being transformed or passed around.

#### Examples:
- **Loan File** – central data container for each financing process
- **Verification Report** – output from verifier about project specs or carbon compliance
- **Vendor Quote** – submitted proposal from a vendor
- **Compliance Certificate** – artifact required by regulators
- **Audit Trail Log** – record of transitions, actions, or approvals

In most platforms, objects are **stored in a database** and serialized as documents (e.g., JSON). Their evolution across time is your system’s **history**.

---

### IV. **State** – _What Status the Object Is In_

A **state** is a label describing the current status of an object **in its lifecycle**. States are finite and discrete—each object can only occupy **one state at a time**, even if it holds multiple pieces of information.

#### Examples for a Loan File:
- Draft
- Submitted
- Under Review
- Awaiting Verification
- Approved
- Disbursed
- Rejected
- Archived

States are the **system’s way of understanding progress**. A properly designed system transitions between states based on defined rules, which is the foundation of automation and workflow management.

---

### Putting It All Together — System Grammar

Let’s now combine these in a systemic sentence:

> **[Actor]** performs an **[Action]** on an **[Object]**, which transitions from **[State A]** to **[State B]**, conditional on validation logic.

#### Example:
> **Vendor** submits a **Vendor Quote** to the **Platform**, which moves the **Loan File** from **"Awaiting Vendor Input"** to **"Ready for Verification"**, assuming the quote includes all required line items.

---

### Why This Matters

- **Actors are decision-rights.** Define them early to prevent scope creep and compliance failure.
- **Actions are triggers.** Automate what can be automated. But always attach actions to auditable records.
- **Objects are the value chain.** They carry the meaning of your product—design them to evolve cleanly.
- **States are control levers.** They let you manage complexity without entropic chaos.

In a startup system, clarity on these constructs lets you build:
- **Robust APIs** (each endpoint = action on object by actor)
- **Workflow engines** (state machines with trigger rules)
- **Audit layers** (every state/action transition is logged)
- **Modular frontends** (each actor sees objects relevant to them, filtered by state)

---

Would you like a canonical schema or diagram template to start defining these for your own platform?