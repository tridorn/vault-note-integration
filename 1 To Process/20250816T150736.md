---
owner: Ben Jendyk
id: c09c2b38-e6a3-4972-b7fa-93721a3322e5
created: 2025-08-16T15:07:36+0200
modified: 2025-08-16T15:07:38+0200
tags: [access/public, language/en]
key-words: []
---

A tighter way to ask: "Should graduated services keep using one central identity and login surface, or fragment authentication per product?"

  

## Verdict

  

Yes. Maintain one central identity provider (IdP) and login surface across all services, including those that graduate. It maximizes user continuity, cross-sell leverage, and operational simplicity. Fragment only when a service's governance or enterprise requirements force it.

  

## Why a single IdP is the rational default

- Conversion and retention: one account lowers friction, reactivates dormant users across products, and enables bundles.
- Lower ops: password resets, MFA, risk scoring, device management handled once.
- Clear analytics: unified user IDs enable lifecycle and LTV measurement across services.
- Entitlements: a single subject identifier lets you grant product-specific access by scope, not by duplicating accounts.

  

## When to break away

- Contractual/regulatory isolation: data residency, sector rules, or customers demanding isolated IdPs.
- Brand separation by design: you intentionally want no cross-discovery or shared telemetry.
- Platform divergence: a service requires auth protocols your core IdP won't support at parity (rare with the choices below).

  

## Architecture that holds when services graduate

- Central IdP on accounts.domain.com (not tied to any app DB). Support OIDC OAuth2, SAML for B2B, MFA, WebAuthn, SCIM.
- Relying parties: each service (including those on new domains) is an OIDC client with its own audience and scopes.
- Stable user identity: use a durable sub (subject) across all clients; prohibit per-app user rows as sources of truth. Services keep a local "profile shadow" keyed by sub.
- Authorization: product entitlements issued as claims (e.g., services: ["notes:pro","images:free"]) or fetched via a lightweight entitlement API.
- Sessions: short-lived access tokens, long-lived refresh tokens; PKCE everywhere. For subdomains, parent-domain session cookie works; for separate domains, use standard OIDC redirects.
- Tenant model (if B2B): organization objects in the IdP; SSO per org via SAML/OIDC; SCIM for user lifecycle.

  

## Tooling choices (pick one, avoid mixing)

- Managed, fastest: Auth0, Clerk, Stytch, WorkOS (strong SAML/SCIM), FusionAuth Cloud.
- Self-hosted: Ory, Keycloak, FusionAuth.
- If you start on Supabase Auth: it's per-project. For cross-service SSO and future splits, front it with a real IdP or plan a migration once the first service graduates. Supabase becomes a relying party, not the identity source.

  

## Concrete implementation plan

1. Stand up the IdP on accounts.domain.com. Enable email/password, OAuth, WebAuthn, TOTP.

2. Define scopes per service: svc:notes.read, svc:notes.write, etc. Add role â†’ scope mapping in the IdP, not app code.

3. Core site hosts the login UI; services use "Continue with domain.com" OIDC flow.

4. Each service stores only sub, email, and minimal profile shadow. All permission checks server-side via token claims or an entitlement API.

5. Stripe links to the IdP user (sub) as the customer key. Entitlements derive from Stripe webhooks mapped to that sub.

6. Caching and resilience: 5--15 minute access tokens, 24--72 hour refresh tokens, rotating keys (JWKS), and a small token cache to survive transient IdP latency.

7. Observability: per-client login success rate, time-to-first-byte post-login, and MFA dropout funnel. Alert on abnormal failure spikes.

  

## Migration when a service graduates to its own domain

- Keep the same IdP. Add a new OIDC client for service.com.
- Update redirects and allowed origins; leave service.domain.com as a 301.
- Do not reissue identities; keep sub stable.
- If finance wants separate Stripe accounts, keep identity shared and map customers by sub; migrate billing gradually via the Billing Portal.

  

## Risks and how to neutralize them

- Blast radius of IdP outage: run IdP in HA regions; keep short-lived tokens and tolerant token caches; fail "read" features open where safe.
- Over-privileged tokens: minimize scopes, rotate keys, audit clients quarterly.
- Data-sharing concerns: by default, include only the minimal claims; fetch anything sensitive from a per-service API under policy.
- Brand divergence: theme the central login per client_id while preserving one backend IdP.

  

## Bottom line

  

Keep one central identity and a single login surface. It compounds user value and reduces operational drag. Only fragment under explicit legal or architectural pressure, and even then, prefer separate tenants inside the same IdP before forking identities.