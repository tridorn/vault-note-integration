---
owner: Ben Jendyk
id: 4c8ac2b9-fbd7-4c77-abea-8728b5cfe692
created: 2025-08-13T21:18:44+0200
modified: 2025-08-13T21:18:46+0200
tags: [access/public, language/en]
key-words: []
aliases: [0. Premise and end-state]
title: 0. Premise and end-state
---

A cleaner phrasing would be: "Describe a step-by-step wedge strategy for a sole founder to build a provider-independent, standards-based company from zero, scale it into a functioning organisation, and preserve architectural discipline throughout."

  

# 0. Premise and end-state

  

Objective: design rails once, then scale the same substrate. You will bias to open standards, declarative state, idempotent automation, and auditable events. Every asset is addressable and reproducible. No undocumented side effects.

  

Success conditions by month three:

- A canonical asset system you can recreate from zero in under one hour.
- A thin control plane API that fronts Git, object storage, database, and identity.
- At least one real service using the rails end-to-end.
- A second user onboarded through the rails with zero manual exceptions.
- Event logs that reconstruct every material change.

  

# 1. Canonical asset system

  

Choose standards, not vendors. Prefer protocols with multiple mature implementations.

  

Core:

- Code and config: Git over SSH/HTTPS, Git LFS optional.
- Blobs and artifacts: S3 API compatible bucket, OCI registry optional later.
- Relational state: PostgreSQL.
- Identity: OIDC for auth, SCIM optional later for provisioning; start with Keycloak or another OIDC provider.
- Events: NATS or Kafka protocol; start with NATS for simplicity.
- Work automation: declarative CI runners that execute YAML from Git.
- Secrets: age + sops committed to Git; keys stored offline and on one hardware token.

  

Asset identifiers:

- URN format for everything to remove provider coupling.

    - git: urn:git:<org>/<repo>@<ref>

    - object: urn:s3:<bucket>/<key>@<version>

    - db: urn:pg:<db>/<schema>.<table>@<snapshot>

    - identity: urn:iam:<realm>/<role>|<user>

    - event: urn:event:<topic>/<type>/<uuid>

  

# 2. Minimal viable rails

  

Run on one VM or laptop via Docker. All components speak open protocols. You can swap vendors by editing endpoints and credentials.

  

Concrete starter set:

- Git: Gitea or GitHub with mirroring enabled.
- Object storage: MinIO locally; plan for S3, R2, or Wasabi later.
- Database: Postgres single node.
- Identity: Keycloak local realm.
- CI: Drone CI or GitHub Actions; both read YAML from repos.
- Events: NATS single node.
- Reverse proxy: Caddy or nginx in front for TLS and routing.
- VPN for admin access: WireGuard.

  

Baseline hardening:

- All services private behind VPN, public only if required.
- All inter-service traffic TLS, even local.
- Immutable image builds and pinned digests.

  

# 3. Repository topology

  

Keep repos narrowly scoped. Enforce PRs for every change.

- infra-bootstrap

    - Terraform providers only for compute/network if any; Ansible or Docker Compose for services.

    - Makefile with make up, make down, make check, make backup.
- docs-policies

    - Principles, SECURITY.md, LICENSE, PR templates, CODEOWNERS.

    - Decision records under decisions/ using ADR format.
- infra-identity

    - Realm, clients, roles, groups as YAML.

    - Scripts to apply via Keycloak admin API or terraform-provider-keycloak.
- ops-scripts

    - Backup, restore, object uploads, DB dump/verify. All idempotent.
- org-structure

    - org.yaml defining units, roles, responsibilities, RBAC bindings.
- control-plane

    - The thin API service that fronts Git, storage, DB, identity and emits events.
- svc-*

    - First service(s). Builds in CI, ships artifacts to object storage, deploys via PR to infra-bootstrap or a deploy-* repo.

  

Minimum contents examples:

  

docs-policies/PR_TEMPLATE.md
    
    
    Summary
    Risk
    Rollback plan
    Affected assets (URNs)
    Event types emitted

docs-policies/CODEOWNERS
    
    
    * @founder
    infra-* @founder
    control-plane @founder

org-structure/org.yaml
    
    
    units:
      - name: Founding
        roles:
          - name: Owner
            responsibilities: [strategy, security, releases]
    people:
      - handle: founder
        roles: [Owner]
    rbac:
      - role: repo-admin
        grants: [git:admin/*]
      - role: storage-writer
        grants: [s3:put/*]
    bindings:
      - handle: founder
        roles: [repo-admin, storage-writer]

# 4. Control plane design

  

Purpose: force yourself and later hires to use the same abstraction. All actions flow through it, even if it wraps local CLIs initially.

  

Authentication and authorization:

- OIDC tokens validated at the edge.
- RBAC claims embedded in tokens based on infra-identity roles.

  

Endpoints v0:

- POST /git/commit with repo, branch, path, message, content.
- POST /storage/put with bucket, key, content hash, optional immutability.
- POST /db/query with prepared statement id plus parameters.
- POST /identity/provision with user handle and role bindings.
- GET /events/subscribe?topic=<t> server-sent events or NATS pass-through.

  

Event emission:
    
    
    {
      "id": "e7e4b1d0-6a2b-4a83-9d0a-0e7d6c8d5f6a",
      "ts": "2025-08-13T12:00:00Z",
      "actor": "urn:iam:founding/founder",
      "action": "git.commit",
      "subject": "urn:git:org/infra-bootstrap@main",
      "claims": {"roles": ["repo-admin"]},
      "correlation_id": "f1f2f3",
      "data": {"paths": ["ops/backup.sh"]},
      "sig": "Detached JWS of event body"
    }

Implementation path:

- Start with FastAPI or Flask plus a thin adapter per backend.
- Adapters talk only standards: libgit2 or CLI, S3 SDK, psycopg2, Keycloak admin API, NATS client.
- Put all adapters behind interfaces so you can swap providers without touching handlers.
- Emit events to NATS and to an append-only table in Postgres for audit.

  

# 5. Events and audit

  

Topics:

- git.*, storage.*, db.*, identity.*, org.*, deploy.*, incident.*.

  

Retention:

- NATS stream with 90 days and size cap.
- Postgres audit table with write-only role, monthly snapshot to object storage.

  

Replay:

- A small replayer in ops-scripts that reads events and reconstructs state for verification.

  

# 6. Workflows for a solo founder

  

Make yourself the first governed entity.

- All changes via PR to relevant repo. No direct pushes to default branches.
- Decisions recorded as ADRs. Link ADR IDs in PRs.
- Tasks as Git issues. Labels reflect risk and area.
- Binary assets to object storage only. Store their URNs in Markdown with checksums.
- First automation: on merge to org-structure, run a job that calls /identity/provision and posts a signed event.

  

# 7. First service wedge

  

Create svc-analytics or any internal service with external value potential.

  

Pipeline blueprint:

1. build: compile, run unit tests, produce artifact, calculate SBOM.

2. scan: SAST and dependency scan. Fail on critical vulnerabilities without documented waiver file.

3. package: publish artifact to object storage as urn:s3:artifacts/svc-analytics/<version>.tar.gz.

4. deploy: open PR to infra-bootstrap to update a version pin. Merge triggers rollout via make deploy.

  

CI YAML minimal sketch:
    
    
    on: [push]
    jobs:
      build:
        runs-on: linux
        steps:
          - uses: actions/checkout@v4
          - run: make test
          - run: make artifact  # writes /dist/svc.tar.gz and SBOM
          - run: ./ops/publish.sh /dist/svc.tar.gz urn:s3:artifacts/svc-analytics/
      deploy:
        needs: build
        if: startsWith(github.ref, 'refs/tags/')
        steps:
          - run: ./ops/open_deploy_pr.sh $GIT_TOKEN $TAG

# 8. Identity and RBAC automation

- Role definitions live in infra-identity/roles/*.yaml.
- Group mapping: human-readable groups map to machine roles.
- Provisioning script:

    - Creates user, assigns groups, creates Git access token with scoped permissions, creates S3 access key with bucket-scoped policy, stores credentials as sealed secrets addressed to the user.
- Offboarding script:

    - Revoke tokens, disable user, rotate service keys, emit identity.offboarded.

  

# 9. Data, config, and secrets

- Use sops to encrypt YAML files in Git. Keys:

    - Offline master, hardware token subkey, a recovery paper key stored physically.
- Configuration layering:

    - defaults.yaml committed.

    - env/{dev,staging,prod}.yaml committed and mostly plain.

    - secrets.yaml encrypted with sops.
- Database:

    - Migrations via dbmate or golang-migrate. Versioned in Git and applied only through control plane job.

    - Nightly verified backup with restore test to throwaway container.

  

# 10. Observability

- Logs: ship JSON logs to local Loki or vector to files, rotate daily, archive to object storage.
- Metrics: start with Prometheus single instance; alert on process up, disk free, backup freshness, failed CI, audit lag.
- Tracing optional in phase two.
- Dashboards: one "State of Rails" dashboard that shows green or red on the basics. No vanity.

  

# 11. Security baseline and threat model

- MFA mandatory on IdP. Hardware token preferred.
- SSH keys short-lived via agent, not long-lived on disk.
- CI runners isolated. Secrets only available to protected branches and tags.
- Dependency policy with allowlist of base images and package sources.
- Threat model v0:

    - Risks: credential theft, poisoned dependencies, data loss, audit gaps.

    - Controls: MFA, SBOM and signature verification, immutable backups, append-only audit, minimal blast radius via scoped tokens.

  

# 12. Cost and capacity

- Phase 1 single VM: 4 vCPU, 16 GB RAM, 200 GB storage. Snapshot daily. Expect low three-digit monthly cost.
- Boundaries:

    - If CPU > 60 percent sustained or storage > 70 percent, move to managed instances for the heavy services.
- Cost levers:

    - Artifacts and backups to cold tier after 30 days.

    - Keep CI runners preemptible if possible.

  

# 13. Scaling triggers and guardrails

- Move to Phase 2 when a second contributor merges twice per week and CI queue time exceeds five minutes.
- Introduce staging when production incident probability rises beyond once per month or you start external users.
- Split repos by domain when svc-* repos exceed five or one repo's PRs block others regularly.
- Enforce SLAs:

    - PR review mean under 24 hours.

    - Incident acknowledge under 15 minutes during working hours.

    - Backup restore test weekly.

  

# 14. Hiring wedge and onboarding

- Onboard only through org-structure PR.
- First day task: PR to docs-policies or ops-scripts that touches the rails.
- Deny any request for out-of-band access. The exception path is a signed, time-boxed waiver stored in Git and emitted as policy.waiver.granted.

  

# 15. Risk ledger and trade-offs

- Trade-off: rails first costs time up front, saves orders of magnitude in migration and compliance. Accept slower first two weeks.
- Trade-off: single VM creates a mild single point of failure, but the cost is justified until you have two people and users. Mitigate via frequent snapshots and restore drills.
- Trade-off: strict API path introduces friction. Pay it to ensure later uniformity. Keep the control plane thin to reduce cognitive load.

  

# 16. Vendor swap playbooks

  

Document exact steps to move each subsystem. Keep config in one file per subsystem.

- Storage swap:

    - Edit storage.yaml endpoint and credentials.

    - Sync MinIO to target using rclone with checksums.

    - Run integrity verifier against URNs and hashes.
- Git swap:

    - Enable mirror to new remote.

    - Freeze writes, cut over DNS, unfreeze.
- IdP swap:

    - Export realm, roles, clients.

    - Import to new OIDC provider with equivalent mappings.

    - Rotate client secrets and publish new OIDC metadata to control plane.

  

# 17. Exit criteria by phase

- Phase 1 complete when you can:

    - Rebuild rails from zero with make up and have control plane responding within one hour.

    - Onboard a collaborator in under 15 minutes via PR and automation.

    - Ship a tagged release of svc-* through CI to running service via PR.
- Phase 2 complete when:

    - Managed Git, storage, and DB in place, same APIs, zero code changes in services.

  

# 18. Twelve-week execution plan

  

Week 1

- Initialize infra-bootstrap with Docker Compose, Gitea or GitHub, MinIO, Postgres, Keycloak, NATS, reverse proxy.
- Create docs-policies, org-structure, ops-scripts, infra-identity.
- Establish sops keys and policy.

  

Week 2

- Bring up IdP realm and initial RBAC roles from infra-identity.
- Wire Git provider OIDC login.
- Implement backups for Postgres and MinIO. Verify restore locally.

  

Week 3

- Scaffold control-plane with OIDC auth, /storage/put, /git/commit, event emission to NATS and audit table.
- Add Makefile commands to interact via control plane, not raw CLIs.

  

Week 4

- Extend control plane to /identity/provision and /db/query with prepared statements.
- Define event schema and correlation IDs. Add signature on events.

  

Week 5

- Enforce PR-only merges. Add CODEOWNERS and branch protection.
- Add ADR template. Document exception waivers.

  

Week 6

- Stand up CI runners. Build pipeline for control-plane.
- Add ops-scripts for backup verification and event replay.

  

Week 7

- Create svc-analytics skeleton. Build, scan, package to object storage. Basic service deploy via PR to infra-bootstrap.

  

Week 8

- Observability: Prometheus, Loki or vector to files, dashboard for rails health.
- Alerts for backup freshness, CI failures, audit writer lag.

  

Week 9

- First collaborator onboarding through org-structure PR, automatic provisioning. First PR task to docs-policies.

  

Week 10

- Hardening pass: secrets scope review, token rotations, dependency pinning, SBOM signing.
- Incident process: incident.md, chat to Git sync bot for decisions within 24 hours.

  

Week 11

- Add staging environment switch in infra-bootstrap. Same control plane API. Blue-green or version-pin deploy.

  

Week 12

- DR drill: rebuild rails on fresh VM from backups and Git. Document gaps.
- Write the quarterly rails report: what changed, incidents, waivers, costs, next triggers.

  

# 19. Concrete commands to anchor discipline

  

Everything via control plane, even solo.

  

Commit a file:
    
    
    curl -H "Authorization: Bearer $TOKEN" \
      -X POST https://cp.local/git/commit \
      -d @- <<'JSON'
    {"repo":"infra-bootstrap","branch":"main","path":"ops/backup.sh",
     "message":"feat(ops): add verified backup script",
     "content_base64":"<...>"}
    JSON

Upload an artifact:
    
    
    curl -H "Authorization: Bearer $TOKEN" \
      -X POST https://cp.local/storage/put \
      -d '{"bucket":"artifacts","key":"svc-analytics/0.1.0.tar.gz","sha256":"..."}'

Provision a user:
    
    
    curl -H "Authorization: Bearer $TOKEN" \
      -X POST https://cp.local/identity/provision \
      -d '{"handle":"alice","roles":["repo-contrib","storage-reader"]}'

# 20. What to avoid

- Ad hoc admin changes. If you must, record a waiver event with expiry.
- Hidden SaaS defaults. Export config and pin versions.
- Long-lived credentials in CI. Use short-lived tokens minted by control plane.

  

# 21. Minimal checklists

  

Daily

- CI red builds, audit writer lag, backup freshness, free space.

  

Weekly

- Restore test, dependency updates, rotate at least one low-risk secret.

  

Monthly

- DR rebuild rehearsal notes, rails report commit, review waivers and close them.

  

This setup keeps leverage high and surface area low. You get uniformity early, optionality later, and migrations become edits rather than rewrites.