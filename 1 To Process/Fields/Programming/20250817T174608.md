---
owner: Ben Jendyk
id: 4d99baaf-22f0-4676-9ffc-cf8f82f1b238
created: 2025-08-17T17:46:08+0200
modified: 2025-08-17T17:46:10+0200
tags: [access/public, language/en]
key-words: []
aliases: ["Recommendation: Distrobox with exported launcher"]
title: "Recommendation: Distrobox with exported launcher"
---

A tighter brief: "Propose a more rational setup for Cursor on Fedora Silverblue than 'raw AppImage in Toolbox', with concrete steps and trade-offs."

  

Here are three viable alternatives. I'll rank them and give you the exact commands for the one that maximises integration with minimal ceremony.

  

# Recommendation: Distrobox with exported launcher

  

Rationale: better desktop integration than plain Toolbox, no host pollution, reversible, and you get .desktop entries that feel native.

  

Setup
    
    
    # 1) Install distrobox on the host (Silverblue)
    rpm-ostree install distrobox
    # reboot or log out/in, then:
    
    # 2) Create a Fedora 42 container
    distrobox create -n cursor-f42 -i registry.fedoraproject.org/fedora:42
    
    # 3) Enter and prepare runtime deps once
    distrobox enter cursor-f42 -- sudo dnf -y install \
      nss nspr libX11 libXcomposite libXcursor libXdamage libXfixes libXi libXtst libXrandr \
      alsa-lib at-spi2-atk at-spi2-core gtk3 libdrm mesa-dri-drivers libgbm libsecret \
      cups-libs libnotify libappindicator-gtk3 xdg-utils libxkbcommon adwaita-gtk3-theme \
      fuse fuse-libs
    
    # 4) Put Cursor AppImage somewhere in $HOME (shared with container)
    mkdir -p ~/.local/opt/cursor
    mv /path/to/Cursor-*.AppImage ~/.local/opt/cursor/Cursor.AppImage
    chmod +x ~/.local/opt/cursor/Cursor.AppImage
    
    # 5) Smoke test
    distrobox enter cursor-f42 -- "$HOME/.local/opt/cursor/Cursor.AppImage"

Export a first-class desktop launcher
    
    
    # Basic launcher (Wayland autodetect)
    distrobox-export --app \
      --name "Cursor" \
      --bin "$HOME/.local/opt/cursor/Cursor.AppImage" \
      --container cursor-f42
    
    # Optional: export with Wayland flags if you see rendering issues
    distrobox-export --app \
      --name "Cursor (Wayland)" \
      --bin "$HOME/.local/opt/cursor/Cursor.AppImage --enable-features=WaylandWindowDecorations --ozone-platform-hint=auto" \
      --container cursor-f42

If FUSE blocks the mount, bypass it permanently
    
    
    distrobox enter cursor-f42 -- bash -lc '
    cd "$HOME/.local/opt/cursor"
    ./Cursor.AppImage --appimage-extract
    printf "%s\n" "#!/usr/bin/env bash" "exec \"$(pwd)/squashfs-root/AppRun\" \"\$@\"" > run-cursor.sh
    chmod +x run-cursor.sh
    '
    # Re-export the app using run-cursor.sh instead of the AppImage
    distrobox-export --app \
      --name "Cursor" \
      --bin "$HOME/.local/opt/cursor/run-cursor.sh" \
      --container cursor-f42

Icon export (optional, makes the menu entry look native)
    
    
    distrobox enter cursor-f42 -- bash -lc '
    cd "$HOME/.local/opt/cursor"
    [ -d squashfs-root ] || ./Cursor.AppImage --appimage-extract || true
    icon="$(find squashfs-root -type f -name "*.png" -o -name "*.svg" | sort -Vr | head -n1)"
    if [ -n "$icon" ]; then
      mkdir -p "$HOME/.local/share/icons/hicolor/512x512/apps"
      cp -f "$icon" "$HOME/.local/share/icons/hicolor/512x512/apps/cursor.png"
    fi
    '
    gtk-update-icon-cache ~/.local/share/icons 2>/dev/null || true

Removal
    
    
    distrobox-export --app --delete --name "Cursor"
    distrobox rm cursor-f42
    rm -rf ~/.local/opt/cursor

Trade-offs

- Pros: native launcher, clean rollback, shared $HOME, minimal overhead, good enough portal/theming behaviour.
- Cons: container lifecycle to maintain; first run has slight cold-start penalty; still manual AppImage updates.

  

# Alternative 2: Self-wrap as a Flatpak (private build)

  

Rationale: maximal desktop integration and portal correctness; aligns with Silverblue's model. Cost: initial setup and you must refresh the wrap on each upstream release.

  

Sketch

1. Install flatpak-builder into a dev container or Toolbox.

2. Create a minimal manifest that vendors the AppImage and runs it via --appimage-extract then AppRun.

3. Bind needed host locations via Flatpak permissions as required.

  

Example cursor.yaml (simplified; build in a container):
    
    
    app-id: io.cursor.Editor
    runtime: org.freedesktop.Platform
    runtime-version: "24.08"
    sdk: org.freedesktop.Sdk
    command: cursor-run
    finish-args:
      - --share=ipc
      - --socket=fallback-x11
      - --socket=wayland
      - --device=dri
      - --talk-name=org.freedesktop.secrets
      - --filesystem=home
    modules:
      - name: cursor
        buildsystem: simple
        build-commands:
          - install -D Cursor.AppImage /app/opt/Cursor.AppImage
          - printf '#!/usr/bin/env bash\ncd /app/opt\n./Cursor.AppImage --appimage-extract >/dev/null 2>&1 || true\nexec /app/opt/squashfs-root/AppRun "$@"\n' > /app/bin/cursor-run
          - chmod +x /app/bin/cursor-run
        sources:
          - type: file
            path: Cursor.AppImage

Build and install:
    
    
    flatpak-builder build-dir cursor.yaml --install --user
    flatpak run io.cursor.Editor

Trade-offs: cleanest integration; but you become the maintainer of your wrapper.

  

# Alternative 3: Nix user-level wrap via

# appimageTools

  

Rationale: hermetic packaging without touching the base OS; reproducible user profile. Cost: bring in Nix.

  

Outline
    
    
    # Install Nix (multi-user or single-user; your call)
    # Then create default.nix with an appimageTools wrapper:
    
    { pkgs ? import <nixpkgs> {} }:
    let
      cursorApp = pkgs.appimageTools.wrapAppImage {
        name = "cursor";
        src = pkgs.fetchurl {
          url = "file:///home/$USER/.local/opt/cursor/Cursor.AppImage"; # or an upstream URL with a fixed hash
          sha256 = "sha256-â€¦"; # fill in
        };
      };
    in pkgs.mkShell { buildInputs = [ cursorApp ]; }
    
    # Enter the shell and run `cursor`

Trade-offs: strong reproducibility, easy rollback; overhead of a parallel package manager and hash updates when upstream changes.

  

# Bottom line

  

Use Distrobox with exported launchers. It gives you the integration you expected from Toolbox without committing to Flatpak maintenance. If Cursor becomes core infrastructure and you want zero friction with portals and themes, invest in the private Flatpak. If you value reproducibility above all, the Nix route is defensible, but it's a heavier operational footprint on Silverblue.