---
owner: Ben Jendyk
id: a0d77575-7aca-41db-b282-509103155b48
created: 2025-08-12T13:48:55+0200
modified: 2025-08-15T18:20:34+0200
tags: [access/public, language/en, a/ip]
key-words: []
---

Alright -- let's unpack the unified, dual-purpose system I just gave you, and go through the thinking behind each part so you can see why it's structured this way and how it works universally for any type of note -- static or dynamic.
* * *

## 1. Why "unified" matters

  

The temptation is always to have different templates for different types of notes: one for projects, another for book summaries, another for research. The problem is that in a knowledge base (especially in Obsidian), that quickly fragments into incompatible formats. Queries, dashboards, and automation suffer because fields aren't consistent.

  

A unified system:

- Uses the same set of blocks across all note types.
- Allows you to query any note for stage, sources, conclusions, etc., without special handling.
- Works with both static content (book notes) and living, evolving work (projects).

  

This universality means you only learn one grammar, and your system never needs "bridging" scripts to compare different note types.

* * *

## 2. Why "dual-purpose" blocks

  

Each block is two-sided:

- Meta side (YAML) = machine-readable data, the source of truth for facts, IDs, and fields.
- Body side (H2 section) = human-readable narrative, interpretation, argument, or description.

  

The Meta is for automation, dashboards, and queries.

The Body is for actual reading, thinking, and meaning.

  

The two are linked by name -- if you have findings in YAML, you also have a ## findings H2 in the body. That keeps your note symmetric and prevents silent "orphan" data that only a script understands.
* * *

## 3. Why these

## twelve

##  primitives

  

I stripped the set down to the minimum universal "jobs" that a note might need to do, without bias toward action or static content.

Here's the reasoning:

  

### identity

- Every note must be identifiable -- what it is, type, unique ID.
- Works for: "Project ABC", "Book: Thinking, Fast and Slow", "Paper: 2023 study on X".

  

### intent

- Captures why the note exists -- the reason you made it.
- For a book note: "Understand author's argument on decision-making."
- For a project: "Deliver X feature by Y date."

  

### sources

- Strictly for bibliographic or formal references.
- Keeps the discipline of traditional note-taking -- avoids lumping books and datasets into one "input" bucket.

  

### inputs

- Any non-bibliographic material -- datasets, prompts, requirements, files.
- Keeps your "raw materials" separate from your "authorities."

  

### method

- The approach you take -- reading strategy, experimental method, workflow.
- Works for: "Read chapters in reverse order to see argument progression" or "Applied regression analysis with Python."

  

### content

- The actual "meat" -- your prose, the working draft, the main notes.
- In a book note: this is your summary.
- In a project: this is your working space.

  

### findings

- The "raw outputs" of your process -- highlights, observations, measurements.
- For a book: quotes or paraphrased key points.
- For a research project: data points, test results.

  

### conclusions

- The interpretation or decision made from findings.
- Static note: "This book supports the idea that…"
- Action note: "We will proceed with design option B."

  

### next

- The follow-up action or main open question.
- For a static note, this might be "Read related book on…"
- For a project: "Prototype next phase by Friday."

  

### state

- Lifecycle + classification.
- Stage and status fields are universal -- static notes can simply be done at creation.

  

### ledger

- A timeline of changes -- optional for static, essential for living notes.

  

### links

- The knowledge graph connection: parents, children, dependencies, related works.
* * *

## 4. Static vs. Action Notes in this System

  

The beauty of this layout is that static notes simply leave certain blocks empty or minimal:

- A book note might have empty next, a single state.stage: done, and no ledger.
- A project note would actively use method, next, ledger, and update state often.

  

But structurally, they're identical -- meaning:
- The same Dataview table can show intent from a book note and from a project note side-by-side.
- You can filter all notes for links.depends_on without caring what kind of note it is.
* * *

## 5. Why sources and inputs are split

  

This is a big one -- in the earlier, purely action-oriented model, "inputs" swallowed everything. But for long-term clarity and interoperability:
- sources = anything citable in a bibliography (books, papers, formal references).
- inputs = working materials that are not themselves works of scholarship (datasets, interview transcripts, design assets).

  

This lets you do:
    
    
    table intent.purpose, sources.items[0].title
    from "Notes"
    where contains(sources.items[].author, "Kahneman")

without having to filter out random datasets or JPEGs.

* * *

## 6. Machine-querying advantage

  

Because every primitive has a meta block, you can run queries like:

- Find all notes with open questions:
    
    
    table intent.purpose, next.action
    where next.action != "" and state.status != "done"

- Find all notes citing a specific DOI or ISBN.
- Generate a reading queue by filtering notes with type: book and state.status: open.
* * *

## 7. Adaptability and Scalability

  

This system is:

- Composable: you can add optional blocks (risks, terms) if your domain needs them, without breaking the base structure.
- Scalable: works for 10 notes or 10,000 notes.
- Resilient: even if you mirror fields to the body and later stop using Dataview, the note still makes sense to a human.
* * *

If you want, I can walk you through exactly how this system would look for the same content as:

1. A project deliverable.

2. A book note.

3. A research paper.

  

That would really show how "universal" it is in practice. Would you like me to do that?