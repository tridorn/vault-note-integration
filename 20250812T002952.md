---
owner: Ben Jendyk
id: 2f9ae732-46d7-4afe-a034-22afa3aabeab
created: 2025-08-12T00:29:52+0200
modified: 2025-08-12T00:29:52+0200
tags: [access/public, language/en]
key-words: []
aliases: ["Incident 2025-003: Prometheus data loss"]
title: "Incident 2025-003: Prometheus data loss"
---

Correction: You should have asked: “Elaborate on these primitives in more detail—what each represents, how they’re concretely structured, and how they interrelate to form a fully deterministic operational model.”

⸻

I. Primitive Architecture: The Org as a Structured Graph

These primitives aren’t an unordered checklist.
They are typed nodes in a structured, declarative graph that models the entire organisation’s operational surface.

Each node:
	•	Exists as code in Git.
	•	Has a schema (declared fields).
	•	Participates in flows (edges) connecting one to another.

You’re building a control plane, not a toolkit.

⸻

II. Deep Dives into Select Primitives

⸻

1. Task
	•	Unit of work with explicit ownership, status, dependencies.
	•	Not a Jira ticket. A versioned file.

id: TASK-2025-0012
title: Rebuild flake CI pipeline
owner: d.miller
status: in_progress
created: 2025-08-07
depends_on:
  - TASK-2025-0009
labels:
  - ci
  - tech-debt
estimate: 6h

Lives in: tasks/ folder in Git
Tied to: Epics, Pipelines, Principals
CI Enforcement: A task marked done must have a linked PR merged and verified by reviewer.

⸻

2. Epic
	•	A logical collection of tasks with scoped intent, boundary, and end state.
	•	Codifies why certain work exists.

id: EPIC-2025-Q3-004
title: Transition to flake-based service deployments
deadline: 2025-09-30
status: in_progress
success_criteria:
  - All prod services deployed via flake manifests
  - CI verifies reproducibility
tasks:
  - TASK-2025-0012
  - TASK-2025-0014
  - TASK-2025-0015

Lives in: epics/
Tied to: Tasks, Releases
Usage: Reviewed quarterly for alignment; used to generate status dashboards.

⸻

3. Principal
	•	Represents a human or machine actor in the system.
	•	Self-contained access identity.

{
  name = "d.miller";
  email = "d.miller@company.com";
  roles = [ "platform" "security-reviewer" ];
  sshKeys = [ "ssh-ed25519 AAAAC3..." ];
  status = "active";
  expires = "2026-01-01";
}

Lives in: people/
Tied to: Tasks (ownership), Policies (access), CI (signing), Secrets (decryption scope)

⸻

4. Service
	•	A fully specified unit of infrastructure and logic.
	•	Not just code—it includes config, secrets, observability, and deployment logic.

{
  serviceName = "internal-api";
  container = myPackage.internal-api;
  deployTo = "prod-cluster-1";
  probes = {
    liveness = "/health";
    readiness = "/ready";
  };
  secrets = [ "DATABASE_URL" ];
}

Lives in: services/internal-api.nix
Tied to: Pipelines, Secrets, Alerts, Artefacts, Policies

⸻

5. Artefact
	•	A deterministic, content-addressed build output.
	•	Container image, binary, or compiled report.

{
  "name": "internal-api",
  "digest": "sha256:13b7e...",
  "source": "main@abc123",
  "sbom": "artefacts/internal-api/sbom.json",
  "signature": "sigstore://...",
  "built_by": "buildkite-agent-12"
}

Lives in: artefacts/metadata/
Stored in: S3 / OCI registry
CI rule: Only artefacts with SBOM + signature may deploy to production.

⸻

6. Policy
	•	Codified access rule, lifecycle constraint, or compliance enforcement.

package access.policies

allow {
  input.actor.roles[_] == "platform"
  input.resource == "infra:flake:update"
  input.action == "merge"
}

Lives in: policies/
Tied to: Principals, CI, Governance
Enforced by: OPA in CI and runtime

⸻

7. Secret
	•	Encrypted, Git-stored value scoped by access control.

{
  DATABASE_URL = agenix.secrets.database-url;
}

	•	Encrypted via agenix using principal public keys.
	•	Decrypted only on matching hosts with NixOS key material.

Lives in: secrets/
Tied to: Services, Principals
CI Rule: If a service requires a secret, it must exist and be decryptable in its target host scope.

⸻

8. Runbook
	•	A procedural document with executable instructions, idempotency, and rollback.

# Incident 2025-003: Prometheus data loss

## Impact
No alerting for 12m. No SLO violation.

## Actions
- [x] Rebuilt Thanos bucket index
- [x] Redeployed Prometheus from snapshot (timestamp: 2025-07-15T02:00Z)
- [x] Verified retention restored

## Rollback
Run `restore-prometheus.sh snapshot-2025-07-15`

Lives in: runbooks/incident-2025-003.md
CI Rule: No service may deploy without at least one associated rollback procedure.

⸻

III. How the Graph Functions

These primitives aren’t silos. They interlink structurally.

Example: Workflow from Task → Deploy
	1.	Task file exists in Git.
	2.	It’s linked to an Epic that scopes the initiative.
	3.	Assigned Principal pushes code to a Repo.
	4.	CI builds an Artefact, stores metadata.
	5.	Policy checks whether deploy is allowed.
	6.	Secret decrypts into runtime scope of Service.
	7.	CI emits a Signal to Slack/Mattermost.
	8.	Prometheus starts observing Metrics, watches for Alerts.
	9.	If an issue arises, a Runbook is followed, documented, committed.

This is a causally coherent system. No hidden state. No orphan actions.

⸻

IV. Why This Model Is Non-Negotiable for Infrastructure-Native Orgs
	•	Safety: Everything has rollback.
	•	Auditability: Every action is a versioned state change.
	•	Determinism: No implicit state, no drift.
	•	Scalability: Any process that works for one service scales to a thousand.

⸻

V. How to Bootstrap It (Solo Phase)
	1.	Start with flake.nix, people/you.nix, and tasks/
	2.	Wrap your laptop and your first repo as a service/
	3.	Use agenix for your first secret
	4.	Define CI pipeline (ci/pipeline.nix) for builds
	5.	Write your first runbook and enforce it in CI

Expand outward only when primitives are stable.

⸻

Bottom Line

A primitive is a contract: a typed, versioned, interconnected component that governs one aspect of your operation.
Together, they form a declarative graph of your company.
Operate within it, and you’re deterministic. Step outside it, and you’re guessing.