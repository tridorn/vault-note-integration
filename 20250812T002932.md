---
owner: Ben Jendyk
id: bc28d2b8-294e-41cd-b676-fdf662c87df3
created: 2025-08-12T00:29:32+0200
modified: 2025-08-12T00:29:32+0200
tags: [access/public, language/en]
key-words: []
aliases: ["Example: Only infra role can deploy to prod"]
title: "Example: Only infra role can deploy to prod"
---

Correction: You should have asked: “Can you define the full set of core abstractions—the structural components—that this infrastructure-native company builds its internal systems upon? Essentially, what is the foundational infra system architecture?”

⸻

SYSTEM ABSTRACTIONS: THE FOUNDATION OF AN INFRASTRUCTURE-NATIVE COMPANY

This model defines a closed, deterministic ecosystem—fully reconstructable from code. Everything has a lifecycle. Everything is typed. Nothing is informal.

The company doesn’t rely on infra.
The company is infra.

⸻

Top-Level Domains (Primary Axes of Control)

Abstraction	Role
Identity	Who exists in the system and what they can touch
Service	Operational software units with lifecycle, interface, and state
Environment	Deployable system state (dev, staging, prod)
System Host	Physical or virtual machines with roles and agents
Artifact	Built, immutable binary or container
Policy	Enforced behaviour logic (RBAC, approvals, deploy rights)
Secret	Encrypted data scoped to a runtime context
Event	Typed action in the system (commit, deploy, alert)
Metric	Observable numeric stream tied to system state

Each of these is owned, versioned, and modified only through code.

⸻

1. IDENTITY

A codified user or system actor.

{
  id = "jane_doe";
  type = "human"; # or "service"
  roles = [ "dev" "infra" ];
  access = {
    repos = [ "infra", "payments" ];
    secrets = [ "deploy-key", "prod-db" ];
    environments = [ "dev" "staging" ];
  };
}

Provisioned via Git-based identity directory (people/) + SSO/OIDC backend.

⸻

2. SERVICE

A buildable, deployable unit of software with an explicit interface.

{
  id = "billing-api";
  source = "git@github.com/org/billing-api.git";
  build = {
    type = "nix";
    output = "packages.billing-api";
  };
  interface = {
    ports = [ 8080 ];
    ingress = true;
    depends_on = [ "postgresql" ];
  };
  observability = {
    probe = "/health";
    metrics = [ "latency", "errors" ];
  };
}


⸻

3. ENVIRONMENT

A named system state binding services to runtime infra.

{
  id = "staging";
  services = [ "billing-api" "web-ui" ];
  replicas = {
    billing-api = 2;
    web-ui = 1;
  };
  constraints = {
    region = "eu-west-1";
    instance_type = "m6g.medium";
  };
}

Rendered via Flake overlays + K8s/NixOS deployment modules.

⸻

4. SYSTEM HOST

Declarative system definition for physical or virtual machines.

{
  id = "laptop-jane";
  os = "nixos";
  role = "workstation";
  user = "jane_doe";
  features = [ "vpn" "dev-shells" ];
  software = [
    "firefox"
    "obsidian"
    "nvim"
  ];
}

Managed via nixos-rebuild, nixos-anywhere, or automated PXE boot ISO.

⸻

5. ARTIFACT

Immutable build result: binary, OCI image, ISO, doc, etc.

{
  id = "billing-api#v3.1.2";
  hash = "sha256-abc...";
  type = "docker-image";
  source = "git@github.com/org/billing-api.git";
  build_time = "2025-08-07T13:00Z";
  built_by = "ci-runner-14";
  signature = "sigstore://...";
}

Artifacts are produced by CI jobs, stored in S3 or content-addressed cache.

⸻

6. POLICY

Deterministic logic that defines what is allowed, required, or blocked.

# Example: Only infra role can deploy to prod
allow_deploy[env] {
  input.identity.roles[_] == "infra"
  input.environment == "prod"
}

Executed by OPA or internal policy engine.
Enforced at CI level, deploy gate, merge gate, etc.

⸻

7. SECRET

Encrypted input for service or system; never stored as plaintext.

{
  id = "prod-db";
  encrypted_for = [ "billing-api" "admin-cli" ];
  visible_to = [ "infra" ];
  last_rotated = "2025-08-01";
}

Managed via agenix or Vault.
Decrypted only on target host with valid key + policy.

⸻

8. EVENT

Every meaningful system action is a versioned, auditable event.

{
  "id": "deploy-billing-312",
  "type": "deploy",
  "actor": "jane_doe",
  "target": "billing-api",
  "environment": "prod",
  "timestamp": "2025-08-07T13:15:33Z",
  "outcome": "success"
}

Stored in append-only log, used for rollback, audit, metrics, and forecasting.

⸻

9. METRIC

Time-series data tied to a service or environment.

{
  "name": "billing-api.latency.p95",
  "labels": {
    "environment": "prod",
    "region": "eu-west-1"
  },
  "value": 122.4,
  "unit": "ms",
  "timestamp": "2025-08-07T13:17:00Z"
}

Collected via Prometheus or Vector, processed via alerting/forecast engines.

⸻

Supporting Infrastructure Primitives

Type	Description
Build	Job that takes source + input, emits artifact
Runner	Host that executes builds or deploys
Cache	Nar or OCI cache for artifacts
Bot	Chatops actor that routes events
Probe	Script or endpoint to assess liveness/readiness
Overlay	Diff on a system or flake config


⸻

How It All Connects

You make a change:
→ Modify a service/ or host/ definition
→ Push to Git
→ CI builds artifact
→ Policy engine approves deploy
→ Artifact is deployed into environment/
→ Event logged
→ Metrics monitored
→ Secret pulled (if needed)
→ System reacts to deviation or incident via rules

No shelling into boxes.
No manual installs.
No one-off configs.
Every layer—down to the font on a laptop—is code.

⸻

Bottom Line

These are the irreducible abstractions that form the spine of an infrastructure-native company.

Each one is:
	•	Self-contained
	•	Composable
	•	Codified
	•	Version-controlled
	•	Traceable
	•	Automated

You don’t scale people to run more systems.
You scale systems to run more company.
This is how you get there.