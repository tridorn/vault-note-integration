---
owner: Ben Jendyk
id: 5c787e2c-0460-4fe6-b7a0-2dda80742bd1
created: 2025-08-13T17:53:34+0200
modified: 2025-08-13T17:53:36+0200
tags: [access/public, language/en]
key-words: []
aliases: [Objectives]
title: Objectives
---

You should have written: "Design a standards-first, vendor-neutral system for structuring source, artifacts, data, automation, and collaboration across Git, S3-compatible storage, SQL (Postgres-first but portable), and Slack as an interface."

  

# Objectives

  

Reduce tool lock-in, preserve portability, and keep enforcement simple. The system below uses widely adopted standards as contracts; tools are interchangeable behind those contracts.

  

# Core invariants (non-negotiable)

- Version control: Git only. One default branch, short-lived feature branches.
- Artifacts: S3 API as the single artifact and binary interface. Any S3-compatible backend suffices.
- Images: OCI images. Any OCI registry is acceptable.
- APIs: OpenAPI 3.1 (+ JSON Schema). Clients and server stubs are generated from spec.
- Events: CloudEvents 1.0 envelopes; payloads validated by JSON Schema.
- DB: SQL as the contract. Migrations are plain SQL with deterministic ordering; Postgres extensions gated behind feature flags.
- Build/Run interface: POSIX make targets (or Taskfile) as the universal automation surface that any CI can invoke.
- Packages: SemVer + "Keep a Changelog" format.
- Signatures/Provenance: OCI-level signatures; SBOMs in SPDX.

  

# Taxonomy (repositories as products)

  

Keep the earlier categories, but bind each to standards and portable layouts.

  

## 1) Operational scripts (

## ops-<domain>-scripts

## )

  

Contract: POSIX-compliant shell and Python 3. No Bashisms unless declared.

Layout:
    
    
    /scripts/<topic>/<name>.sh|py
    /scripts/lib/posix.sh
    /tests/ (shunit2 or pytest, smoke tests)
    /Makefile (see "Universal Make targets")

Artifacts: packaged as a .tar.gz to S3: s3://artifacts/ops/<name>/<version>/<name>.tar.gz with checksum + SPDX SBOM.

  

## 2) Reusable libraries (

## lib-<lang>-<domain>

## )

  

Contract: SemVer, language-native packaging, API docs autogenerated from source annotations.

Layout:
    
    
    /src/<pkg>/
    /tests/
    /docs/
    /CHANGELOG.md (Keep a Changelog)

Artifacts: source tarballs and compiled wheels/jars to S3 under libraries/; additionally publish to the language registry if desired.

  

## 3) Services (

## svc-<name>

## )

  

Contract: OpenAPI 3.1 spec in repo is the source of truth. OCI image is the release artifact.

Layout:
    
    
    /api/openapi.yaml          # required
    /cmd/<binary>/             # entrypoint
    /src/ or /internal/
    /configs/                  # 12-factor env, config via env vars + files
    /deploy/                   # k8s manifests OR docker-compose (both OCI)
    /migrations/               # 0001_init.sql, etc.
    /tests/unit, /tests/contract
    /docs/runbook.md

Artifacts: OCI image, SBOM (SPDX), signature, and an exportable config bundle (.env.example + sample compose).

  

## 4) Infrastructure as Code (

## infra-<scope>

## )

  

Contract: Declarative plans and policy as code; state backend abstracted.

Layout:
    
    
    /envs/dev|staging|prod/
    /modules/
    /policies/ (OPA rego)
    /plans/ (generated; gitignored)

Artifacts: plan files and policy reports stored to S3: infra/plans/<repo>/<commit>/.

  

## 5) Automation and pipelines (

## automation-<platform-agnostic>

## )

  

Contract: All jobs callable via make with no CI-specific logic embedded. Provide thin adapters for any CI (GitHub, GitLab, Jenkins).

Layout:
    
    
    /workflows/<name>.mk       # composable make includes
    /lib/                      # reusable shell/python
    /tests/

Artifacts: reusable make includes versioned and released to S3.

  

## 6) Data science and reporting (

## lab-<topic>

## ,

## report-<topic>

## )

  

Contract: Reproducibility via lockfile and manifest; data via signed pointers, not blobs.

Layout:
    
    
    /notebooks/
    /src/
    /data/README.md            # pointers, never data
    /models/                   # pointers (e.g., SHA + S3 path)
    /reports/

Artifacts: frozen reports (PDF/HTML) and model bundles (.tar.gz) to S3 with checksums and SBOMs.

  

## 7) Templates (

## template-<stack>

## )

  

Contract: Copier/Cookiecutter templates producing the above layouts and Make targets.

Artifacts: template tarballs to S3; versioned with SemVer.

  

## 8) Dotfiles and devcontainers (

## dotfiles

## ,

## devcontainer-<lang>

## )

  

Contract: POSIX-portable shell; devcontainers compliant with the Dev Container spec.

  

## 9) Handbook and Standards (

## handbook

## ,

## standards

## )

  

Contract: Markdown, indexed table of repos, owners, lifecycle; normative references to standards used.

  

# Universal Make targets (portable automation surface)

  

Every repo ships these phony targets. Any CI calls them; local developers do the same.
    
    
    make init          # fetch deps, validate environment
    make lint          # static checks
    make test          # unit tests
    make build         # compile/package or image build
    make sbom          # generate SPDX SBOM (e.g., syft)
    make sign          # sign artifact/image (OCI signature)
    make artifact      # stage artifact(s) under ./dist
    make publish       # upload ./dist to S3 and (if relevant) OCI registry
    make clean         # remove build artifacts
    make run           # local run (docker compose or binary)
    make migrate       # apply db migrations (idempotent)
    make contract      # validate OpenAPI/JSON Schema and contract tests

Document these in /README.md. If make is unwelcome, mirror with a Taskfile.yml using the same verbs.

  

# Artifact and data layout in S3 (provider-independent)

  

Use a single, predictable namespace. Folders are contracts, not suggestions.
    
    
    s3://<org>-artifacts/
      libraries/<name>/<version>/{src.tar.gz, wheel.jar,..., SBOM.spdx.json, SHA256SUMS}
      services/<svc>/<version>/{manifest.json, SBOM.spdx.json, RELEASE_NOTES.md}
      images/<svc>/<version>/oci-index.json        # optional export
      ops/<name>/<version>/<name>.tar.gz
      reports/<topic>/<YYYY-MM-DD>/<report>.pdf
      infra/plans/<repo>/<commit>/<env>.plan
      provenance/<repo>/<version>/{attestation.json}

Bucket controls:

- Object Lock (compliance mode) for release artifacts.
- Server-side encryption.
- Lifecycle: move to infrequent access after 30 days, archive after 1 year, retain latest N per channel.

  

# API and contract governance

- OpenAPI 3.1 required for any HTTP service. Lint with spectral.
- Backward compatibility checked in CI by comparing main vs PR specs; breaking changes demand a major version bump.
- Client SDKs generated into separate lib-* repos to avoid vendoring.
- Events must use CloudEvents with type, source, id, time; payload validated against JSON Schema stored under /events/schemas/.

  

# Database standards

- Migrations are plain SQL files with monotonic prefixes: 0001_*.sql. No tool-specific DSL required to run them.
- Optional Postgres features must sit behind capability flags and are isolated in separate migrations named pgext_*.
- make migrate runs via a tiny POSIX wrapper that reads DATABASE_URL and applies migrations transactionally.
- Schema diffs are produced as SQL, stored to S3 on release.

  

# Configuration, secrets, and environments

- 12-factor env vars. Provide .env.example; never commit .env.
- Secret material never in Git. Use a secrets manager; local dev uses .env injected at runtime.
- Configuration files are plain YAML/TOML validated by JSON Schema shipped in the repo.
- Environment overlays: configs/base/ + configs/<env>/ with strict key whitelisting.

  

# Supply chain and integrity

- SBOMs in SPDX for every artifact.
- Sign OCI images and checksums for tarballs.
- Provenance attestations (intoto-like JSON) stored under provenance/ in S3.
- Reproducible builds target where feasible; capture build metadata in dist/manifest.json.

  

# Observability baseline (portable)

- Logs: structured JSON; no library lock-in.
- Metrics: OpenMetrics exposition; any Prometheus-compatible scraper works.
- Tracing: W3C TraceContext headers; optional OTLP export behind config flag.

  

# ChatOps over Slack without lock-in

- All automations expose a thin HTTP endpoint that accepts Slack slash-command payloads and generic webhooks.
- Commands map to the same make targets. Slack is a client; the contract is HTTP + JSON, documented in the repo.
- Outbound notifications use a generic webhook formatter; Slack is one adapter.

  

# Licensing defaults (standard, not tool)

- Public libraries: Apache-2.0 unless ecosystem strongly prefers MIT.
- Services and ops repos: default Apache-2.0 if public; otherwise private.
- Templates: Apache-2.0.
- Reports: CC BY-4.0 unless sensitive.
- Keep to these two: Apache-2.0 and MIT, plus CC BY-4.0 for docs.

  

# Governance and lifecycle

- CODEOWNERS with exactly one accountable team, one deputy.
- Lifecycle labels: incubating, active, maintenance, deprecated, archived.
- Releases: SemVer for libraries/services; date tags for ops and reports.
- Changelogs follow "Keep a Changelog."
- Every release writes to S3, signs, and publishes release notes.

  

# CI/CD, kept portable

  

Any CI that can execute shell can run this. The CI only does:

1. Check out repo.

2. make init lint test build sbom artifact sign

3. make publish with S3 credentials and OCI credentials if applicable.

4. For services, deploy step calls deploy/ scripts that emit standard manifests.

  

Provide thin adapters:
    
    
    /ci/github.yml      # calls make targets
    /ci/gitlab.yml
    /ci/jenkinsfile

Adapters stay trivial; all logic remains in repo or automation-*.

  

# Adoption plan (minimal disruption)

- Week 1--2: ship template-* and automation-* with universal Make targets and OpenAPI/CloudEvents scaffolds.
- Week 3--4: inventory repos; add Makefile, CHANGELOG.md, LICENSE, CODEOWNERS, .env.example. Start emitting SBOMs and signing artifacts.
- Week 5--6: move binary releases to S3 layout; keep legacy paths as read-only mirrors for one release cycle.
- Week 7--8: enforce spec linting and contract checks for services; require OpenAPI in PRs touching /api/.
- Week 9+: migrate CI to call Make, delete bespoke logic.

  

# Trade-offs and consequences

- Standard contracts reduce tool agility cost; you lose some convenience from deep vendor features.
- Plain SQL migrations avoid lock-in but demand discipline; advanced Postgres features become optional modules.
- Universal Make targets unify automation at the cost of a bit more shell hygiene.
- S3 as the artifact spine simplifies auditing and mirroring; you must manage retention and object locking explicitly.

  

# Copy-paste defaults

  

Makefile skeleton
    
    
    .PHONY: init lint test build sbom sign artifact publish clean run migrate contract
    
    init:        ## prepare env
    	./scripts/bootstrap.sh
    
    lint:
    	./scripts/lint.sh
    
    test:
    	./scripts/test.sh
    
    build:
    	./scripts/build.sh
    
    sbom:
    	./scripts/sbom.sh
    
    sign:
    	./scripts/sign.sh
    
    artifact:
    	mkdir -p dist && ./scripts/package.sh
    
    publish:
    	./scripts/publish_s3.sh dist
    
    clean:
    	rm -rf dist
    
    run:
    	./scripts/run_local.sh
    
    migrate:
    	./scripts/migrate.sh
    
    contract:
    	./scripts/contract_check.sh

S3 artifact manifest (dist/manifest.json)
    
    
    {
      "name": "svc-orders",
      "version": "1.4.2",
      "commit": "abc1234",
      "artifacts": [
        {"path":"svc-orders_1.4.2_oci.txt","type":"oci-index"},
        {"path":"SBOM.spdx.json","type":"sbom"},
        {"path":"RELEASE_NOTES.md","type":"notes"}
      ],
      "checksums": "SHA256SUMS"
    }

Adopt this system as written. It fixes portability at the contract level: Git for source, S3 for artifacts, OCI for executables, OpenAPI/CloudEvents for interfaces, SQL for data. Tools can change without rewriting how you work.